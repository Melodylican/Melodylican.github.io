<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>不卑不亢不慌不忙</title>
    <link>http://Melodylican.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>life is struggle</description>
    <pubDate>Fri, 03 Nov 2017 01:49:22 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Java 线程间的状态转换</title>
      <link>http://Melodylican.github.io/2017/11/03/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</link>
      <guid>http://Melodylican.github.io/2017/11/03/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</guid>
      <pubDate>Thu, 02 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;线程间的状态转换： &lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://ojwkevhas.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ol
      
      </description>
      
      <content:encoded><![CDATA[<p>线程间的状态转换： </p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg" alt=""><br></center>

<ol>
<li><p>新建(new)：新创建了一个线程对象。</p>
</li>
<li><p>可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p>
</li>
<li><p>运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p>
</li>
<li><p>阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p>
</li>
</ol>
<p>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</p>
<p>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</p>
<p>(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>
<ol>
<li>死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ol>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/03/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java技能图谱</title>
      <link>http://Melodylican.github.io/2017/11/01/java%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</link>
      <guid>http://Melodylican.github.io/2017/11/01/java%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</guid>
      <pubDate>Tue, 31 Oct 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://ojwkevhas.bkt.clouddn.com/2.1%20JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E5%9B%BE%E8%B0%B1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;
      
      </description>
      
      <content:encoded><![CDATA[<center><br><img src="http://ojwkevhas.bkt.clouddn.com/2.1%20JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E5%9B%BE%E8%B0%B1.png" alt=""><br><a id="more"></a><br><img src="http://ojwkevhas.bkt.clouddn.com/1.2%20Java%E6%9E%B6%E6%9E%84%E5%B8%88%E5%9B%BE%E8%B0%B1.jpg" alt=""><br><br><img src="http://ojwkevhas.bkt.clouddn.com/2.3%20Java%E9%9B%86%E5%90%88%E5%9B%BE%E8%B0%B1.jpg" alt=""><br><br><img src="http://ojwkevhas.bkt.clouddn.com/2.7%20Java%20Set%E7%B1%BB%E5%9B%BE.jpg" alt=""><br><br><img src="http://ojwkevhas.bkt.clouddn.com/2.5%20Java%20List%E7%B1%BB%E5%9B%BE.jpg" alt=""><br><br><img src="http://ojwkevhas.bkt.clouddn.com/2.4%20Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%BE.jpg" alt=""><br><br><img src="http://ojwkevhas.bkt.clouddn.com/2.2%20Java%E5%B9%B6%E5%8F%91%E5%9B%BE%E8%B0%B1.jpg" alt=""><br></center>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/01/java%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Elasticsearch日志清理脚本</title>
      <link>http://Melodylican.github.io/2017/10/20/ES%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/</link>
      <guid>http://Melodylican.github.io/2017/10/20/ES%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/</guid>
      <pubDate>Thu, 19 Oct 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;有的时候我们在使用ES时，由于资源有限或业务需求，我们只想保存最近一段时间的数据，所以有如下脚本可以定时删除数据&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>有的时候我们在使用ES时，由于资源有限或业务需求，我们只想保存最近一段时间的数据，所以有如下脚本可以定时删除数据</p>
<a id="more"></a> 
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="comment"># example: sh  delete_es_by_day.sh logstash-* logsdate 30</span></div><div class="line"></div><div class="line">index_name=<span class="variable">$1</span></div><div class="line">daycolumn=<span class="variable">$2</span></div><div class="line">savedays=<span class="variable">$3</span></div><div class="line">format_day=<span class="variable">$4</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$savedays</span>"</span> ]; <span class="keyword">then</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"the args is not right,please input again...."</span></div><div class="line">  <span class="built_in">exit</span> 1</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$format_day</span>"</span> ]; <span class="keyword">then</span></div><div class="line">   format_day=<span class="string">'%Y%m%d'</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line">sevendayago=`date <span class="_">-d</span> <span class="string">"-<span class="variable">$&#123;savedays&#125;</span> day "</span> +<span class="variable">$&#123;format_day&#125;</span>`</div><div class="line"></div><div class="line">curl -XDELETE <span class="string">"172.16.150.170:9200/<span class="variable">$&#123;index_name&#125;</span>/_query?pretty"</span> <span class="_">-d</span> <span class="string">"</span></div><div class="line">&#123;</div><div class="line">        "query<span class="string">": &#123;</span></div><div class="line">                "filtered<span class="string">": &#123;</span></div><div class="line">                        "filter<span class="string">": &#123;</span></div><div class="line">                                "bool<span class="string">": &#123;</span></div><div class="line">                                        "must<span class="string">": &#123;</span></div><div class="line">                                                "range<span class="string">": &#123;</span></div><div class="line">                                                        "<span class="variable">$&#123;daycolumn&#125;</span><span class="string">": &#123;</span></div><div class="line">                                                                "from<span class="string">": null,</span></div><div class="line">                                                                "to<span class="string">": <span class="variable">$&#123;sevendayago&#125;</span>,</span></div><div class="line">                                                                "include_lower<span class="string">": true,</span></div><div class="line">                                                                "include_upper<span class="string">": true</span></div><div class="line">                                                        &#125;</div><div class="line">                                                &#125;</div><div class="line">                                        &#125;</div><div class="line">                                &#125;</div><div class="line">                        &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">&#125;"</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"ok"</span></div></pre></td></tr></table></figure>
<p>注解：脚本传入参数说明：1.索引名；2.日期字段名；3.保留最近几天数据，单位天；4.日期格式，可不输（默认形式20171020）</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/10/20/ES%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux日志清理</title>
      <link>http://Melodylican.github.io/2017/10/16/Linux%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86%E6%97%A5%E5%BF%97/</link>
      <guid>http://Melodylican.github.io/2017/10/16/Linux%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Sun, 15 Oct 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;linux是一个很能自动产生文件的系统，日志、邮件、备份等。虽然现在硬盘廉价，我们可以有很多硬盘空间供这些文件浪费，让系统定时清理一些不需要的文件很有一种爽快的事情。不用你去每天惦记着是否需要清理日志，不用每天收到硬盘空间不足的报警短信，想好好休息的话，让我们把这个事情交给机器定时去执行吧。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>linux是一个很能自动产生文件的系统，日志、邮件、备份等。虽然现在硬盘廉价，我们可以有很多硬盘空间供这些文件浪费，让系统定时清理一些不需要的文件很有一种爽快的事情。不用你去每天惦记着是否需要清理日志，不用每天收到硬盘空间不足的报警短信，想好好休息的话，让我们把这个事情交给机器定时去执行吧。<br><a id="more"></a></p>
<p><strong>1.删除文件命令</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find 对应目录 -mtime +天数 -name &quot;文件名&quot; -exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure></p>
<p>实例命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find /opt/soft/log/ -mtime +30 -name &quot;*.log&quot; -exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure></p>
<p>说明：</p>
<p>将/opt/soft/log/目录下所有30天前带”.log”的文件删除。具体参数说明如下：</p>
<p>find：linux的查找命令，用户查找指定条件的文件；</p>
<p>/opt/soft/log/：想要进行清理的任意目录；</p>
<p>-mtime：标准语句写法；</p>
<p>+30：查找30天前的文件，这里用数字代表天数；</p>
<p>“<em>.log”：希望查找的数据类型，”</em>.jpg”表示查找扩展名为jpg的所有文件，”*”表示查找所有文件，这个可以灵活运用，举一反三；</p>
<p>-exec：固定写法；</p>
<p>rm -rf：强制删除文件，包括目录；</p>
<p>{} \; ：固定写法，一对大括号+空格++; </p>
<p><strong>2.计划任务</strong>：</p>
<p>若嫌每次手动执行语句太麻烦，可以将这小语句写到一个可执行shell脚本文件中，再设置cron调度执行，那就可以让系统自动去清理相关文件。</p>
<p><strong>2.1创建shell</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">touch /opt/soft/bin/auto-del-30-days-ago-log.sh</div><div class="line"></div><div class="line">chmod +x auto-del-30-days-ago-log.sh</div></pre></td></tr></table></figure></p>
<p>新建一个可执行文件auto-del-30-days-ago-log.sh，并分配可运行权限</p>
<p><strong>2.2编辑shell脚本</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi auto-del-30-days-ago-log.sh</div></pre></td></tr></table></figure></p>
<p>编辑auto-del-30-days-ago-log.sh文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">find /opt/soft/log/ -mtime +30 -name &quot;*.log&quot; -exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure>
<p>ok，保存退出(:wq)。</p>
<p><strong>2.3计划任务</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#crontab -e</div></pre></td></tr></table></figure></p>
<p>将auto-del-30-days-ago-log.sh执行脚本加入到系统计划任务，到点自动执行</p>
<p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 0 * * * /opt/soft/log/auto-del-7-days-ago-log.sh</div></pre></td></tr></table></figure></p>
<p>这里的设置是每天凌晨0点10分执行auto-del-7-days-ago-log.sh文件进行数据清理任务了。</p>
<p>完成以上三步，你就再也不每天惦记是否硬盘空间满了，该清理日志文件了，再也不会受到服务器硬盘空间不足的报警信息了，放心的去看书喝咖啡去吧！</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/10/16/Linux%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86%E6%97%A5%E5%BF%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>架构之路</title>
      <link>http://Melodylican.github.io/2017/10/12/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/</link>
      <guid>http://Melodylican.github.io/2017/10/12/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/</guid>
      <pubDate>Wed, 11 Oct 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;安全优化&quot;&gt;&lt;a href=&quot;#安全优化&quot; class=&quot;headerlink&quot; title=&quot;安全优化&quot;&gt;&lt;/a&gt;安全优化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;阿里云的VPN虚拟专有网络以及安全组配置&lt;/li&gt;
&lt;li&gt;自建机房的话，要自行配置防火墙安全策略&lt;/li&gt;
&lt;li&gt;相关服务访问，比如Mysql、Redis、Solr等如果没有特殊需求尽量使用内网访问并设置鉴权&lt;/li&gt;
&lt;li&gt;尽量使用代理服务器，不要对外开放过多的端口&lt;/li&gt;
&lt;li&gt;https配合HTTP/2.0也是个不错的选择&lt;/li&gt;&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="安全优化"><a href="#安全优化" class="headerlink" title="安全优化"></a>安全优化</h2><ul>
<li>阿里云的VPN虚拟专有网络以及安全组配置</li>
<li>自建机房的话，要自行配置防火墙安全策略</li>
<li>相关服务访问，比如Mysql、Redis、Solr等如果没有特殊需求尽量使用内网访问并设置鉴权</li>
<li>尽量使用代理服务器，不要对外开放过多的端口</li>
<li>https配合HTTP/2.0也是个不错的选择<a id="more"></a>
<h2 id="架构装逼必备词汇"><a href="#架构装逼必备词汇" class="headerlink" title="架构装逼必备词汇"></a>架构装逼必备词汇</h2><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3></li>
<li>负载均衡（负载均衡算法）</li>
<li>反向代理</li>
<li>服务隔离</li>
<li>服务限流</li>
<li>服务降级（自动优雅降级）</li>
<li>失效转移</li>
<li>超时重试</li>
<li>回滚机制</li>
</ul>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><ul>
<li>应用缓存</li>
<li>HTTP缓存</li>
<li>多级缓存</li>
<li>分布式缓存</li>
<li>连接池</li>
<li>异步并发</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><ul>
<li>二阶段提交(强一致)</li>
<li>三阶段提交(强一致)</li>
<li>消息中间件(最终一致性)，推荐阿里的RocketMQ</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>任务队列</li>
<li>消息队列</li>
<li>请求队列</li>
</ul>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul>
<li>单体垂直扩容</li>
<li>单体水平扩容</li>
<li>应用拆分</li>
<li>数据库拆分</li>
<li>数据库分库分表</li>
<li>数据异构</li>
<li>分布式任务</li>
</ul>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><ul>
<li>SQL注入</li>
<li>XSS攻击</li>
<li>CSRF攻击</li>
<li>拒绝服务（DoS，Denial　of　Service）攻击</li>
</ul>
<h2 id="架构装逼必备工具"><a href="#架构装逼必备工具" class="headerlink" title="架构装逼必备工具"></a>架构装逼必备工具</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>Linux（必备）、某软的</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>DNS、F5、LVS、Nginx、HAproxy、负载均衡SLB（阿里云）</p>
<h3 id="分布式框架"><a href="#分布式框架" class="headerlink" title="分布式框架"></a>分布式框架</h3><p>Dubbo、Motan、Spring-Could</p>
<h3 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h3><p>DRDS （阿里云）、Mycat、360 Atlas、Cobar (不维护了)</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>RabbitMQ、ZeroMQ、Redis、ActiveMQ、Kafka</p>
<h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>Zookeeper、Redis</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Redis、Oscache、Memcache、Ehcache</p>
<h3 id="集成部署"><a href="#集成部署" class="headerlink" title="集成部署"></a>集成部署</h3><p>Docker、Jenkins、Git、Maven</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>OSS、NFS、FastDFS、MogileFS</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>MySql、Redis、MongoDB、PostgreSQL、Memcache、HBase</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>专用网络VPC、弹性公网IP、CDN</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/10/12/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>解决npm install很缓慢的问题</title>
      <link>http://Melodylican.github.io/2017/10/10/%E8%A7%A3%E5%86%B3npm-install%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <guid>http://Melodylican.github.io/2017/10/10/%E8%A7%A3%E5%86%B3npm-install%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Mon, 09 Oct 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;使用NPM（Node.js包管理工具）安装依赖时速度特别慢，为了安装Express，执行命令后两个多小时都没安装成功，最后只能取消安装，笔者20M带宽，应该不是我网络的原因，后来在网上找了好久才找到一种最佳解决办法，在安装时可以手动指定从哪个镜像服务器获取资源，我们可以使用阿里巴巴在国内的镜像服务器，命令如下：&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>使用NPM（Node.js包管理工具）安装依赖时速度特别慢，为了安装Express，执行命令后两个多小时都没安装成功，最后只能取消安装，笔者20M带宽，应该不是我网络的原因，后来在网上找了好久才找到一种最佳解决办法，在安装时可以手动指定从哪个镜像服务器获取资源，我们可以使用阿里巴巴在国内的镜像服务器，命令如下：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -gd express --registry=http://registry.npm.taobao.org</div></pre></td></tr></table></figure></p>
<p>只需要使用–registry参数指定镜像服务器地址，为了避免每次安装都需要–registry参数，可以使用如下命令进行永久设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config set registry http://registry.npm.taobao.org</div></pre></td></tr></table></figure>
<p>换了国内镜像，安装速度就很快了。</p>
<p>Ubuntu16.04亲测有效。</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/10/10/%E8%A7%A3%E5%86%B3npm-install%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Kafka offset的重置</title>
      <link>http://Melodylican.github.io/2017/09/25/kafka-offset%E7%9A%84%E9%87%8D%E7%BD%AE/</link>
      <guid>http://Melodylican.github.io/2017/09/25/kafka-offset%E7%9A%84%E9%87%8D%E7%BD%AE/</guid>
      <pubDate>Sun, 24 Sep 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在spark读取kafka消息时，每次读取都会从kafka最新的offset读取。但是如果数据丢失，如果在使用Kafka来分发消息，在数据处理的过程中可能会出现处理程序出异常或者是其它的错误，会造成数据丢失或不一致。这个时候你也许会想要通过kafka把数据从新处理一遍，或者指定kafka的offset读取。kafka默认会在磁盘上保存到7天的数据，你只需要把kafka的某个topic的consumer的offset设置为某个值或者是最小值，就可以使该consumer从你设置的那个点开始消费。这就需要从zk里面修改offset的值。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在spark读取kafka消息时，每次读取都会从kafka最新的offset读取。但是如果数据丢失，如果在使用Kafka来分发消息，在数据处理的过程中可能会出现处理程序出异常或者是其它的错误，会造成数据丢失或不一致。这个时候你也许会想要通过kafka把数据从新处理一遍，或者指定kafka的offset读取。kafka默认会在磁盘上保存到7天的数据，你只需要把kafka的某个topic的consumer的offset设置为某个值或者是最小值，就可以使该consumer从你设置的那个点开始消费。这就需要从zk里面修改offset的值。<br> <a id="more"></a></p>
<h2 id="查询topic的offset的范围"><a href="#查询topic的offset的范围" class="headerlink" title="查询topic的offset的范围"></a>查询topic的offset的范围</h2><p>用下面命令可以查询到topic:DynamicRange broker:SparkMaster:9092的offset的最小值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list slave6:9092 -topic videoplay --time -2</div></pre></td></tr></table></figure></p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DynamicRange:0:1288</div></pre></td></tr></table></figure>
<h2 id="查询offset的最大值："><a href="#查询offset的最大值：" class="headerlink" title="查询offset的最大值："></a>查询offset的最大值：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list slave6:9092 -topic videoplay --time -1</div></pre></td></tr></table></figure>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DynamicRange:0:7885</div></pre></td></tr></table></figure>
<p>从上面的输出可以看出topic:DynamicRange只有一个partition:0 offset范围为:[1288,7885]</p>
<p>设置consumer group的offset<br>启动zookeeper client<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/zookeeper/bin/zkCli.sh</div></pre></td></tr></table></figure></p>
<p>通过下面命令设置consumer group:DynamicRangeGroup topic:DynamicRange partition:0的offset为1288:</p>
<p>set /consumers/DynamicRangeGroup/offsets/DynamicRange/0 1288</p>
<p>注意如果你的kafka设置了zookeeper root，比如为/kafka，那么命令应该改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set /kafka/consumers/DynamicRangeGroup/offsets/DynamicRange/0 1288</div></pre></td></tr></table></figure></p>
<h2 id="生效"><a href="#生效" class="headerlink" title="生效"></a>生效</h2><p>重启相关的应用程序，就可以从设置的offset开始读数据了。 </p>
<p>参考：<a href="https://metabroadcast.com/blog/resetting-kafka-offsets" target="_blank" rel="external">https://metabroadcast.com/blog/resetting-kafka-offsets</a></p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/09/25/kafka-offset%E7%9A%84%E9%87%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spark应用案例-关于购物篮的设计</title>
      <link>http://Melodylican.github.io/2017/08/21/spark%E8%B4%AD%E7%89%A9%E7%AF%AE%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://Melodylican.github.io/2017/08/21/spark%E8%B4%AD%E7%89%A9%E7%AF%AE%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Mon, 21 Aug 2017 08:42:23 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;h3 id=&quot;购物篮的定义&quot;&gt;&lt;a href=&quot;#购物篮的定义&quot; class=&quot;headerlink&quot; title=&quot;购物篮的定义&quot;&gt;&lt;/a&gt;购物篮的定义&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="购物篮的定义"><a href="#购物篮的定义" class="headerlink" title="购物篮的定义"></a>购物篮的定义</h3><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE1.png" alt=""><br></center>

<a id="more"></a>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE2.png" alt=""><br></center><br>　<br>### 相关概念 ###<br><br><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE3.png" alt=""><br></center>　<br><br>### 步骤 ###<br><br><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE4.png" alt=""><br></center>　　<br><br>### 编程实现 ###<br><br><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE5.png" alt=""><br></center>　<br>　<br>### 步骤 ###<br><br><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE6.png" alt=""><br></center>　<br>　　<br><br>## 程序实现 ##<br><br>### 程序 ###<br><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.&#123;<span class="type">FileSystem</span>, <span class="type">Path</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</div><div class="line"></div><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * 使用SparkCore实现购物篮分析</div><div class="line">  */</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">FindAssociationRulesSparkCore</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 先从缓存中获取数据，如果不存在，直接重新获取</div><div class="line">    *</div><div class="line">    * @param items</div><div class="line">    * @param size</div><div class="line">    * @param cache</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findItemSetsByCache</span></span>(items: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)], size: <span class="type">Int</span>, cache: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]): <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = &#123;</div><div class="line">    cache.get(size).orElse &#123;</div><div class="line">      <span class="comment">// 获取值</span></div><div class="line">      <span class="keyword">val</span> result = findItemSets(items, size, cache)</div><div class="line"></div><div class="line">      <span class="comment">// 更新缓存</span></div><div class="line">      cache += size -&gt; result</div><div class="line"></div><div class="line">      <span class="comment">// 返回值</span></div><div class="line">      <span class="type">Some</span>(result)</div><div class="line">    &#125;.get</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 构建项集基于items商品列表，项集中的商品数量是size指定</div><div class="line">    *</div><div class="line">    * @param items 商品列表：eg: [A, B, C]</div><div class="line">    * @param size  最终项集包含商品的数量</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findItemSets</span></span>(items: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)], size: <span class="type">Int</span>, cache: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]): <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = &#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">// items中的每个商品都是一个项集</span></div><div class="line">      items.map(item =&gt; item :: <span class="type">Nil</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 当size不是1的时候</span></div><div class="line">      <span class="comment">// 1. 获取项集大小为size-1的项集列表</span></div><div class="line">      <span class="keyword">val</span> tmpItemSets = findItemSetsByCache(items, size - <span class="number">1</span>, cache)</div><div class="line">      <span class="comment">// 2. 给tmpItemSets中添加一个新的不重复的项 ==&gt; 数据的转换</span></div><div class="line">      <span class="keyword">val</span> itemSets = tmpItemSets.flatMap(itemSets =&gt; &#123;</div><div class="line">        <span class="comment">// 给itemSets项集添加一个新的商品ID，要求不重复</span></div><div class="line">        <span class="keyword">val</span> newItemSets = items</div><div class="line">          <span class="comment">// 将包含的商品过滤掉&amp;要求下标必须大于以及存在</span></div><div class="line">          .filter(item =&gt; !itemSets.contains(item) &amp;&amp; itemSets.forall(_._2 &lt; item._2))</div><div class="line">          <span class="comment">// 将商品添加到项集中，产生一个新的项集</span></div><div class="line">          <span class="comment">// 为了使用distinct做去重操作，进行一个排序操作</span></div><div class="line">          .map(item =&gt; (item :: itemSets))</div><div class="line"></div><div class="line">        <span class="comment">// 返回值</span></div><div class="line">        newItemSets</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 返回项集的值</span></div><div class="line">      itemSets</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="comment">// 1. 创建SparkContext</span></div><div class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</div><div class="line">      .setAppName(<span class="string">"find-association-rules"</span>)</div><div class="line">      .setMaster(<span class="string">"local[*]"</span>)</div><div class="line">    <span class="keyword">val</span> sc = <span class="type">SparkContext</span>.getOrCreate(conf)</div><div class="line"></div><div class="line">    <span class="comment">// ===========================================</span></div><div class="line">    <span class="comment">// 测试数据存储的路径</span></div><div class="line">    <span class="keyword">val</span> path = <span class="string">"data/transactions/10"</span></div><div class="line">    <span class="keyword">val</span> savePath = <span class="string">"data/transactions/result"</span></div><div class="line">    <span class="comment">// 最小支持度</span></div><div class="line">    <span class="keyword">val</span> minSupport = <span class="number">2</span></div><div class="line">    <span class="comment">// 最小置信度</span></div><div class="line">    <span class="keyword">val</span> minConfidence = <span class="number">0.4</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建rdd读取原始的交易数据，</span></div><div class="line">    <span class="comment">// 假设交易数据是按行存储的，每行是一条交易，每条交易数据包含的商品ID使用","分割</span></div><div class="line">    <span class="keyword">val</span> rdd = sc.textFile(path, <span class="number">20</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 1. 计算频繁项集</span></div><div class="line">    <span class="comment">// 1.1 获取每条交易存在的项集</span></div><div class="line">    <span class="keyword">val</span> itemSetsRDD: <span class="type">RDD</span>[<span class="type">String</span>] = rdd.flatMap(transaction =&gt; &#123;</div><div class="line">      <span class="comment">// 1) 获取当前交易所包含的商品ID</span></div><div class="line">      <span class="keyword">val</span> items = transaction</div><div class="line">        .split(<span class="string">","</span>) <span class="comment">// 分割</span></div><div class="line">        .filter(!_.isEmpty) <span class="comment">// 过滤</span></div><div class="line">        .sorted <span class="comment">//排序</span></div><div class="line">        .toList <span class="comment">// 转换为list</span></div><div class="line">        .zipWithIndex <span class="comment">// 将数据和下标合并，下标从0开始</span></div><div class="line"></div><div class="line">      <span class="comment">// 2) 构建辅助对象</span></div><div class="line">      <span class="keyword">val</span> itemSize = items.size</div><div class="line">      <span class="keyword">val</span> cache = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]()</div><div class="line"></div><div class="line">      <span class="comment">// 3) 根据获取的商品ID的信息产生项集</span></div><div class="line">      <span class="comment">// allItemSets集合中最后数据量是:2^itemSize - 1</span></div><div class="line">      <span class="keyword">val</span> allItemSets: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]] = (<span class="number">1</span> to itemSize).map(size =&gt; &#123;</div><div class="line">        <span class="comment">// 产生项集中项的数量是size的项集</span></div><div class="line">        findItemSets(items, size, cache)</div><div class="line">      &#125;).foldLeft(<span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]())((v1, v2) =&gt; &#123;</div><div class="line">        v2.map(_.map(_._1)) ::: v1</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 4) 返回结果</span></div><div class="line">      allItemSets.map(_.mkString(<span class="string">","</span>))</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 1.2 获取频繁项集</span></div><div class="line">    <span class="keyword">val</span> supportedItemSetsRDD = itemSetsRDD</div><div class="line">      <span class="comment">// 数据转换</span></div><div class="line">      .map(items =&gt; (items, <span class="number">1</span>))</div><div class="line">      <span class="comment">// 聚合求支持度</span></div><div class="line">      .reduceByKey(_ + _)</div><div class="line">      <span class="comment">// 过滤产生频繁项集</span></div><div class="line">      .filter(_._2 &gt;= minSupport)</div><div class="line"></div><div class="line">    <span class="comment">// 2. 计算关联规则</span></div><div class="line">    <span class="comment">// 2.1 对每个频繁项集获取子项集</span></div><div class="line">    <span class="keyword">val</span> subSupportedItemSetsRDD = supportedItemSetsRDD.flatMap(tuple =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> itemSets = tuple._1.split(<span class="string">","</span>).toList.zipWithIndex <span class="comment">// 频繁项集</span></div><div class="line">      <span class="keyword">val</span> frequency = tuple._2 <span class="comment">// 该频繁项集的支持度</span></div><div class="line"></div><div class="line">      <span class="comment">// 2) 构建辅助对象</span></div><div class="line">      <span class="keyword">val</span> itemSize = itemSets.size</div><div class="line">      <span class="keyword">val</span> cache = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]()</div><div class="line"></div><div class="line">      <span class="comment">// 3) 获取子项集</span></div><div class="line">      <span class="keyword">val</span> allSubItemSets: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]] = (<span class="number">1</span> to itemSize).map(size =&gt; &#123;</div><div class="line">        <span class="comment">// 产生项集中项的数量是size的项集</span></div><div class="line">        findItemSets(itemSets, size, cache)</div><div class="line">      &#125;).foldLeft(<span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]())((v1, v2) =&gt; &#123;</div><div class="line">        v2.map(_.map(_._1)) ::: v1</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 4) 转换数据并输出</span></div><div class="line">      <span class="keyword">val</span> items = itemSets.map(_._1)</div><div class="line">      allSubItemSets.map(subItemSets =&gt; &#123;</div><div class="line">        <span class="comment">// (A,B,frequency) ==&gt; 表示A出现的时候B也出现的次数是frequency次</span></div><div class="line">        <span class="comment">// 当subItemSets就是itemSets的时候，返回的二元组的第二个元素的(元组)第一个元素是空的列表</span></div><div class="line">        (subItemSets.mkString(<span class="string">","</span>), ((items.toBuffer -- subItemSets).toList.mkString(<span class="string">","</span>), frequency))</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 计算置信度</span></div><div class="line">    <span class="keyword">val</span> assocRulesRDD = subSupportedItemSetsRDD</div><div class="line">      .groupByKey() <span class="comment">// 数据聚合</span></div><div class="line">      .flatMap(tuple =&gt; &#123;</div><div class="line">      <span class="comment">// 计算执行度: (A, B, k) =&gt; A存在的时候B也存储的几率是k</span></div><div class="line">      <span class="comment">// A就是tuple的第一个元素</span></div><div class="line">      <span class="comment">// 获取左件</span></div><div class="line">      <span class="keyword">val</span> lhs = tuple._1.split(<span class="string">","</span>).mkString(<span class="string">"&lt;"</span>, <span class="string">","</span>, <span class="string">"&gt;"</span>)</div><div class="line"></div><div class="line">      <span class="comment">// 获取左件在所有的交易中出现的总的次数 tuple._2中第一个元素为空的数据就是总的次数</span></div><div class="line">      <span class="keyword">val</span> frequency = tuple._2</div><div class="line">        <span class="comment">// 只要第一个元素为空的值，表示from本身</span></div><div class="line">        .filter(_._1.isEmpty)</div><div class="line">        <span class="comment">// 需要的是第二个元素</span></div><div class="line">        .map(_._2).toList <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> head :: <span class="type">Nil</span> =&gt; head</div><div class="line">        <span class="keyword">case</span> _ =&gt; &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"异常"</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 计算右件出现次数占左件次数的百分比, 并返回最终结果</span></div><div class="line">      tuple._2</div><div class="line">        <span class="comment">// 要求第一个数据非空</span></div><div class="line">        .filter(!_._1.isEmpty)</div><div class="line">        <span class="comment">// 数据转换，获取置信度</span></div><div class="line">        .map &#123;</div><div class="line">        <span class="keyword">case</span> (rhs, support) =&gt; &#123;</div><div class="line">          <span class="comment">// 计算置信度</span></div><div class="line">          (lhs, rhs.split(<span class="string">","</span>).mkString(<span class="string">"&lt;"</span>, <span class="string">","</span>, <span class="string">"&gt;"</span>), <span class="number">1.0</span> * support / frequency)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 过滤置信度太低的数据</span></div><div class="line">    <span class="keyword">val</span> resultRDD = assocRulesRDD.filter(_._3 &gt;= minConfidence)</div><div class="line"></div><div class="line">    <span class="comment">// 3. RDD数据保存</span></div><div class="line">    <span class="comment">//resultRDD.collect()</span></div><div class="line">    <span class="type">FileSystem</span>.get(sc.hadoopConfiguration).delete(<span class="keyword">new</span> <span class="type">Path</span>(savePath), <span class="literal">true</span>)</div><div class="line">    <span class="comment">//resultRDD.repartition(1).saveAsTextFile(savePath)</span></div><div class="line"></div><div class="line">    <span class="comment">// ===========================================</span></div><div class="line">    sc.stop()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>### 注意点（本地的完全运行） ###<br><br>　　不需要开启服务，也不需要上传文件，讲文件保存在本地的方式<br><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE7.png" alt=""><br></center>

<h2 id="优化程序"><a href="#优化程序" class="headerlink" title="优化程序"></a>优化程序</h2><p>　　1.优化的是相集的个数</p>
<p>　　2.使用广播变量</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.&#123;<span class="type">FileSystem</span>, <span class="type">Path</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.broadcast.<span class="type">Broadcast</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</div><div class="line"></div><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * 使用SparkCore实现购物篮分析</div><div class="line">  */</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">FindAssociationRulesSparkCore</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 先从缓存中获取数据，如果不存在，直接重新获取</div><div class="line">    *</div><div class="line">    * @param items</div><div class="line">    * @param size</div><div class="line">    * @param cache</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findItemSetsByCache</span></span>(items: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)], size: <span class="type">Int</span>, cache: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]): <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = &#123;</div><div class="line">    cache.get(size).orElse &#123;</div><div class="line">      <span class="comment">// 获取值</span></div><div class="line">      <span class="keyword">val</span> result = findItemSets(items, size, cache)</div><div class="line"></div><div class="line">      <span class="comment">// 更新缓存</span></div><div class="line">      cache += size -&gt; result</div><div class="line"></div><div class="line">      <span class="comment">// 返回值</span></div><div class="line">      <span class="type">Some</span>(result)</div><div class="line">    &#125;.get</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 构建项集基于items商品列表，项集中的商品数量是size指定</div><div class="line">    *</div><div class="line">    * @param items 商品列表：eg: [A, B, C]</div><div class="line">    * @param size  最终项集包含商品的数量</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findItemSets</span></span>(items: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)], size: <span class="type">Int</span>, cache: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]): <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = &#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">// items中的每个商品都是一个项集</span></div><div class="line">      items.map(item =&gt; item :: <span class="type">Nil</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 当size不是1的时候</span></div><div class="line">      <span class="comment">// 1. 获取项集大小为size-1的项集列表</span></div><div class="line">      <span class="keyword">val</span> tmpItemSets = findItemSetsByCache(items, size - <span class="number">1</span>, cache)</div><div class="line">      <span class="comment">// 2. 给tmpItemSets中添加一个新的不重复的项 ==&gt; 数据的转换</span></div><div class="line">      <span class="keyword">val</span> itemSets = tmpItemSets.flatMap(itemSets =&gt; &#123;</div><div class="line">        <span class="comment">// 给itemSets项集添加一个新的商品ID，要求不重复</span></div><div class="line">        <span class="keyword">val</span> newItemSets = items</div><div class="line">          <span class="comment">// 将包含的商品过滤掉&amp;要求下标必须大于以及存在</span></div><div class="line">          .filter(item =&gt; !itemSets.contains(item) &amp;&amp; itemSets.forall(_._2 &lt; item._2))</div><div class="line">          <span class="comment">// 将商品添加到项集中，产生一个新的项集</span></div><div class="line">          <span class="comment">// 为了使用distinct做去重操作，进行一个排序操作</span></div><div class="line">          .map(item =&gt; (item :: itemSets))</div><div class="line"></div><div class="line">        <span class="comment">// 返回值</span></div><div class="line">        newItemSets</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 返回项集的值</span></div><div class="line">      itemSets</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> n = <span class="number">10000</span></div><div class="line">    <span class="comment">// 1. 创建SparkContext</span></div><div class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</div><div class="line">      .setAppName(<span class="string">s"find-association-rules-<span class="subst">$&#123;n&#125;</span>"</span>)</div><div class="line">      .setMaster(<span class="string">"local[*]"</span>)</div><div class="line">    <span class="comment">//      .set("spark.eventLog.enabled", "true")</span></div><div class="line">    <span class="comment">//      .set("spark.eventLog.dir","hdfs://hadoop-senior01:8020/spark-history")</span></div><div class="line">    <span class="comment">//      .set("spark.executor.memory","3g")</span></div><div class="line">    <span class="keyword">val</span> sc = <span class="type">SparkContext</span>.getOrCreate(conf)</div><div class="line"></div><div class="line">    <span class="comment">// ===========================================</span></div><div class="line">    <span class="comment">// 测试数据存储的路径</span></div><div class="line">    <span class="keyword">val</span> path = <span class="string">s"data/transactions/<span class="subst">$&#123;n&#125;</span>"</span></div><div class="line">    <span class="keyword">val</span> savePath = <span class="string">s"result2/<span class="subst">$&#123;n&#125;</span>"</span></div><div class="line">    <span class="comment">// 最小支持度</span></div><div class="line">    <span class="keyword">val</span> minSupport = <span class="number">2</span></div><div class="line">    <span class="comment">// 最小置信度</span></div><div class="line">    <span class="keyword">val</span> minConfidence = <span class="number">0.1</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建rdd读取原始的交易数据，</span></div><div class="line">    <span class="comment">// 假设交易数据是按行存储的，每行是一条交易，每条交易数据包含的商品ID使用","分割</span></div><div class="line">    <span class="keyword">val</span> rdd = sc.textFile(path, <span class="number">20</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 过滤无效数据：对于在整个交易集合中出现比较少的商品过滤掉，先进行需要过滤的商品的RDD数据</span></div><div class="line">    <span class="keyword">val</span> minGoodCount = <span class="number">3</span> <span class="comment">// 要求商品在整个交易集中至少出现3次</span></div><div class="line">    <span class="keyword">val</span> needFilterGoodsRDD = rdd</div><div class="line">      .flatMap(transaction =&gt; transaction</div><div class="line">        .split(<span class="string">","</span>)</div><div class="line">        .filter(!_.isEmpty)</div><div class="line">        .map(good =&gt; (good, <span class="number">1</span>))</div><div class="line">      )</div><div class="line">      .reduceByKey(_ + _)</div><div class="line">      .filter(_._2 &lt; minGoodCount)</div><div class="line">      .map(_._1)</div><div class="line">    <span class="comment">// 使用广播变量将数据广播输出</span></div><div class="line">    <span class="keyword">val</span> needFilterGoods: <span class="type">Broadcast</span>[<span class="type">List</span>[<span class="type">String</span>]] = sc.broadcast(needFilterGoodsRDD.collect().toList)</div><div class="line"></div><div class="line">    <span class="comment">// 1. 计算频繁项集</span></div><div class="line">    <span class="comment">// 1.1 获取每条交易存在的项集</span></div><div class="line">    <span class="keyword">val</span> itemSetsRDD: <span class="type">RDD</span>[<span class="type">String</span>] = rdd.flatMap(transaction =&gt; &#123;</div><div class="line">      <span class="comment">// 1) 获取当前交易所包含的商品ID</span></div><div class="line">      <span class="keyword">val</span> goods: <span class="type">Array</span>[<span class="type">String</span>] = transaction</div><div class="line">        .split(<span class="string">","</span>) <span class="comment">// 分割</span></div><div class="line">        .filter(!_.isEmpty) <span class="comment">// 过滤</span></div><div class="line"></div><div class="line"></div><div class="line">      <span class="comment">// 将需要过滤的数据过滤掉</span></div><div class="line">      <span class="keyword">val</span> items = (goods.toBuffer -- needFilterGoods.value)</div><div class="line">        .sorted <span class="comment">//排序</span></div><div class="line">        .toList <span class="comment">// 转换为list</span></div><div class="line">        .zipWithIndex <span class="comment">// 将数据和下标合并，下标从0开始</span></div><div class="line"></div><div class="line">      <span class="comment">// 2) 构建辅助对象</span></div><div class="line">      <span class="comment">// 最大的项集只允许存在5个项的，5怎么来？根据业务规则&amp;根据运行之后的情况</span></div><div class="line">      <span class="keyword">val</span> itemSize = <span class="type">Math</span>.min(items.size, <span class="number">5</span>)</div><div class="line">      <span class="keyword">val</span> cache = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]()</div><div class="line"></div><div class="line">      <span class="comment">// 3) 根据获取的商品ID的信息产生项集</span></div><div class="line">      <span class="comment">// allItemSets集合中最后数据量是:2^itemSize - 1</span></div><div class="line">      <span class="keyword">val</span> allItemSets: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]] = (<span class="number">1</span> to itemSize).map(size =&gt; &#123;</div><div class="line">        <span class="comment">// 产生项集中项的数量是size的项集</span></div><div class="line">        findItemSets(items, size, cache)</div><div class="line">      &#125;).foldLeft(<span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]())((v1, v2) =&gt; &#123;</div><div class="line">        v2.map(_.map(_._1)) ::: v1</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 4) 返回结果</span></div><div class="line">      allItemSets.map(_.mkString(<span class="string">","</span>))</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 1.2 获取频繁项集</span></div><div class="line">    <span class="keyword">val</span> supportedItemSetsRDD = itemSetsRDD</div><div class="line">      <span class="comment">// 数据转换</span></div><div class="line">      .map(items =&gt; (items, <span class="number">1</span>))</div><div class="line">      <span class="comment">// 聚合求支持度</span></div><div class="line">      .reduceByKey(_ + _)</div><div class="line">      <span class="comment">// 过滤产生频繁项集</span></div><div class="line">      .filter(_._2 &gt;= minSupport)</div><div class="line"></div><div class="line">    <span class="comment">// 2. 计算关联规则</span></div><div class="line">    <span class="comment">// 2.1 对每个频繁项集获取子项集</span></div><div class="line">    <span class="keyword">val</span> subSupportedItemSetsRDD = supportedItemSetsRDD.flatMap(tuple =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> itemSets = tuple._1.split(<span class="string">","</span>).toList.zipWithIndex <span class="comment">// 频繁项集</span></div><div class="line">      <span class="keyword">val</span> frequency = tuple._2 <span class="comment">// 该频繁项集的支持度</span></div><div class="line"></div><div class="line">      <span class="comment">// 2) 构建辅助对象</span></div><div class="line">      <span class="keyword">val</span> itemSize = itemSets.size</div><div class="line">      <span class="keyword">val</span> cache = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]()</div><div class="line"></div><div class="line">      <span class="comment">// 3) 获取子项集</span></div><div class="line">      <span class="keyword">val</span> allSubItemSets: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]] = (<span class="number">1</span> to itemSize).map(size =&gt; &#123;</div><div class="line">        <span class="comment">// 产生项集中项的数量是size的项集</span></div><div class="line">        findItemSets(itemSets, size, cache)</div><div class="line">      &#125;).foldLeft(<span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]())((v1, v2) =&gt; &#123;</div><div class="line">        v2.map(_.map(_._1)) ::: v1</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 4) 转换数据并输出</span></div><div class="line">      <span class="keyword">val</span> items = itemSets.map(_._1)</div><div class="line">      allSubItemSets.map(subItemSets =&gt; &#123;</div><div class="line">        <span class="comment">// (A,B,frequency) ==&gt; 表示A出现的时候B也出现的次数是frequency次</span></div><div class="line">        <span class="comment">// 当subItemSets就是itemSets的时候，返回的二元组的第二个元素的(元组)第一个元素是空的列表</span></div><div class="line">        (subItemSets.mkString(<span class="string">","</span>), ((items.toBuffer -- subItemSets).toList.mkString(<span class="string">","</span>), frequency))</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 计算置信度</span></div><div class="line">    <span class="keyword">val</span> assocRulesRDD = subSupportedItemSetsRDD</div><div class="line">      .groupByKey() <span class="comment">// 数据聚合</span></div><div class="line">      .flatMap(tuple =&gt; &#123;</div><div class="line">      <span class="comment">// 计算执行度: (A, B, k) =&gt; A存在的时候B也存储的几率是k</span></div><div class="line">      <span class="comment">// A就是tuple的第一个元素</span></div><div class="line">      <span class="comment">// 获取左件</span></div><div class="line">      <span class="keyword">val</span> lhs = tuple._1.split(<span class="string">","</span>).mkString(<span class="string">"&lt;"</span>, <span class="string">","</span>, <span class="string">"&gt;"</span>)</div><div class="line"></div><div class="line">      <span class="comment">// 获取左件在所有的交易中出现的总的次数 tuple._2中第一个元素为空的数据就是总的次数</span></div><div class="line">      <span class="keyword">val</span> frequency = tuple._2</div><div class="line">        <span class="comment">// 只要第一个元素为空的值，表示from本身</span></div><div class="line">        .filter(_._1.isEmpty)</div><div class="line">        <span class="comment">// 需要的是第二个元素</span></div><div class="line">        .map(_._2).toList <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> head :: <span class="type">Nil</span> =&gt; head</div><div class="line">        <span class="keyword">case</span> _ =&gt; &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"异常"</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 计算右件出现次数占左件次数的百分比, 并返回最终结果</span></div><div class="line">      tuple._2</div><div class="line">        <span class="comment">// 要求第一个数据非空</span></div><div class="line">        .filter(!_._1.isEmpty)</div><div class="line">        <span class="comment">// 数据转换，获取置信度</span></div><div class="line">        .map &#123;</div><div class="line">        <span class="keyword">case</span> (rhs, support) =&gt; &#123;</div><div class="line">          <span class="comment">// 计算置信度</span></div><div class="line">          (lhs, rhs.split(<span class="string">","</span>).mkString(<span class="string">"&lt;"</span>, <span class="string">","</span>, <span class="string">"&gt;"</span>), <span class="number">1.0</span> * support / frequency)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 过滤置信度太低的数据</span></div><div class="line">    <span class="keyword">val</span> resultRDD = assocRulesRDD.filter(_._3 &gt;= minConfidence)</div><div class="line"></div><div class="line">    <span class="comment">// 3. RDD数据保存</span></div><div class="line">    <span class="type">FileSystem</span>.get(sc.hadoopConfiguration).delete(<span class="keyword">new</span> <span class="type">Path</span>(savePath), <span class="literal">true</span>)</div><div class="line">    resultRDD.repartition(<span class="number">1</span>).saveAsTextFile(savePath)</div><div class="line"></div><div class="line">    <span class="comment">// ===========================================</span></div><div class="line">    sc.stop()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="grey" size="1">注：此博客仅供博主自身复习用</font>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/21/spark%E8%B4%AD%E7%89%A9%E7%AF%AE%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spark优化</title>
      <link>http://Melodylican.github.io/2017/08/20/spark%E4%BC%98%E5%8C%96/</link>
      <guid>http://Melodylican.github.io/2017/08/20/spark%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sun, 20 Aug 2017 08:42:23 GMT</pubDate>
      <description>
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ojwkevhas.bkt.clouddn.com/spark%E4%BC%98%E5%8C%96.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/center&gt;

&lt;font color=&quot;grey&quot; size=&quot;1
      
      </description>
      
      <content:encoded><![CDATA[<center><br><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E4%BC%98%E5%8C%96.png" alt=""><br><br></center>

<font color="grey" size="1">注：此博客仅供博主自身复习用</font>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/20/spark%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spark应用案例-Spark完成PV和UV的计算</title>
      <link>http://Melodylican.github.io/2017/08/20/spark%E5%AE%8C%E6%88%90PV%E5%92%8CUV%E7%9A%84%E8%AE%A1%E7%AE%97/</link>
      <guid>http://Melodylican.github.io/2017/08/20/spark%E5%AE%8C%E6%88%90PV%E5%92%8CUV%E7%9A%84%E8%AE%A1%E7%AE%97/</guid>
      <pubDate>Sun, 20 Aug 2017 08:42:23 GMT</pubDate>
      <description>
      
        &lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
      
      </description>
      
      <content:encoded><![CDATA[<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">LogPVAndUV</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span>=&#123;</div><div class="line">        <span class="keyword">val</span> conf=<span class="keyword">new</span> <span class="type">SparkConf</span>()</div><div class="line">            .setMaster(<span class="string">"local[*]"</span>)</div><div class="line">            .setAppName(<span class="string">"PVAndUV"</span>)</div><div class="line">        <span class="keyword">val</span> sc=<span class="type">SparkContext</span>.getOrCreate(conf)</div><div class="line">        <span class="keyword">val</span> logPath=<span class="string">"/user/***/spark/logs/page_views.data"</span></div><div class="line">        <span class="keyword">val</span> logRDD=sc.textFile(logPath)</div><div class="line">        <span class="keyword">val</span> filterRDD=logRDD.filter(_.length&gt;<span class="number">0</span>)</div><div class="line">        <span class="comment">//转换</span></div><div class="line">        <span class="keyword">val</span> mapRDD=filterRDD.map(line=&gt;&#123;</div><div class="line">            <span class="keyword">val</span> arr=line.split(<span class="string">"\t"</span>)</div><div class="line">            <span class="keyword">if</span>(arr.length==<span class="number">7</span>)&#123;</div><div class="line">                <span class="keyword">val</span> date=arr(<span class="number">0</span>).trim</div><div class="line">                <span class="keyword">val</span> url=arr(<span class="number">1</span>)</div><div class="line">                <span class="keyword">val</span> uuid=arr(<span class="number">2</span>)</div><div class="line">                (date.subString(<span class="number">0</span>,<span class="type">Math</span>.min(<span class="number">10.</span>date.length)).trim,url,uuid)</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                (<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;).filter(tuple=&gt;tuple._1!=<span class="literal">null</span>&amp;&amp;tuple._1.length&gt;<span class="number">0</span>)</div><div class="line">        <span class="comment">//PV计算</span></div><div class="line">        <span class="keyword">val</span> pvRDD=mapRDD</div><div class="line">            .filter(tuple=&gt;tuple._2.length&gt;<span class="number">0</span>)</div><div class="line">            .map(tuple=&gt;(tuple._1,<span class="number">1</span>))</div><div class="line">            .reduceByKey(_+_)</div><div class="line">        <span class="comment">//UV计算</span></div><div class="line">        <span class="keyword">val</span> uvRDD=mapRDD</div><div class="line">            .filter(tuple=&gt;tuple._3.length&gt;<span class="number">0</span>)</div><div class="line">            .map(tuple=&gt;(tuple._1,tuple._3))</div><div class="line">            .distinct</div><div class="line">            .reduceByKey(_+_)</div><div class="line">        <span class="comment">//合并</span></div><div class="line">        <span class="keyword">val</span> pvAndUv=pvRDD.join(uvRDD).map&#123;</div><div class="line">            <span class="keyword">case</span> (date,(pv,uv))=&gt;&#123;</div><div class="line">                (date,pv,uv)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//输出</span></div><div class="line">        pvAndUv.saveAsTextFile(<span class="string">"/user/***/spark/output/"</span>+<span class="type">System</span>.currentTimeMillis())</div><div class="line">        sc.stop()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="grey" size="1">注：此博客仅供博主自身复习用</font>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/20/spark%E5%AE%8C%E6%88%90PV%E5%92%8CUV%E7%9A%84%E8%AE%A1%E7%AE%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spark应用案例 日志数据分析案例</title>
      <link>http://Melodylican.github.io/2017/08/20/Spark%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</link>
      <guid>http://Melodylican.github.io/2017/08/20/Spark%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</guid>
      <pubDate>Sat, 19 Aug 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;四个需求&quot;&gt;&lt;a href=&quot;#四个需求&quot; class=&quot;headerlink&quot; title=&quot;四个需求&quot;&gt;&lt;/a&gt;四个需求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;　　需求一：求contentsize的平均值、最小值、最大值 &lt;/li&gt;
&lt;li&gt;　　需求二：请各个不同返回值的出现的数据 ===&amp;gt; wordCount程序 &lt;/li&gt;
&lt;li&gt;　　需求三：获取访问次数超过N次的IP地址 &lt;/li&gt;
&lt;li&gt;　　需求四：获取访问次数最多的前K个endpoint的值 ==&amp;gt; TopN&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="四个需求"><a href="#四个需求" class="headerlink" title="四个需求"></a>四个需求</h2><ul>
<li>　　需求一：求contentsize的平均值、最小值、最大值 </li>
<li>　　需求二：请各个不同返回值的出现的数据 ===&gt; wordCount程序 </li>
<li>　　需求三：获取访问次数超过N次的IP地址 </li>
<li>　　需求四：获取访问次数最多的前K个endpoint的值 ==&gt; TopN</li>
</ul>
<a id="more"></a>
<h2 id="主程序LogAnalyzer-scala"><a href="#主程序LogAnalyzer-scala" class="headerlink" title="主程序LogAnalyzer.scala"></a>主程序LogAnalyzer.scala</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * Apache日志分析</div><div class="line">  */</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">LogAnalyzer</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</div><div class="line">      .setAppName(<span class="string">"log-analyzer"</span>)</div><div class="line">      .setMaster(<span class="string">"local[*]"</span>)</div><div class="line">      .set(<span class="string">"spark.eventLog.enabled"</span>, <span class="string">"true"</span>)</div><div class="line">      .set(<span class="string">"spark.eventLog.dir"</span>, <span class="string">"hdfs://hadoop-senior01:8020/spark-history"</span>)</div><div class="line">    <span class="keyword">val</span> sc = <span class="type">SparkContext</span>.getOrCreate(conf)</div><div class="line"></div><div class="line">    <span class="comment">// ================日志分析具体代码==================</span></div><div class="line">    <span class="comment">// HDFS上日志存储路径</span></div><div class="line">    <span class="keyword">val</span> path = <span class="string">"/beifeng/spark/access/access.log"</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建rdd</span></div><div class="line">    <span class="keyword">val</span> rdd = sc.textFile(path)</div><div class="line"></div><div class="line">    <span class="comment">// rdd转换，返回进行后续操作</span></div><div class="line">    <span class="keyword">val</span> apacheAccessLog: <span class="type">RDD</span>[<span class="type">ApacheAccessLog</span>] = rdd</div><div class="line">      <span class="comment">// 过滤数据</span></div><div class="line">      .filter(line =&gt; <span class="type">ApacheAccessLog</span>.isValidateLogLine(line))</div><div class="line">      .map(line =&gt; &#123;</div><div class="line">        <span class="comment">// 对line数据进行转换操作</span></div><div class="line">        <span class="type">ApacheAccessLog</span>.parseLogLine(line)</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 对多次时候用的rdd进行cache</span></div><div class="line">    apacheAccessLog.cache()</div><div class="line"></div><div class="line">    <span class="comment">// 需求一：求contentsize的平均值、最小值、最大值</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    * The average, min, and max content size of responses returned from the server.</div><div class="line">    * */</div><div class="line">    <span class="keyword">val</span> contentSizeRDD: <span class="type">RDD</span>[<span class="type">Long</span>] = apacheAccessLog</div><div class="line">      <span class="comment">// 提取计算需要的字段数据</span></div><div class="line">      .map(log =&gt; (log.contentSize))</div><div class="line"></div><div class="line">    <span class="comment">// 对重复使用的RDD进行cache</span></div><div class="line">    contentSizeRDD.cache()</div><div class="line"></div><div class="line">    <span class="comment">// 开始计算平均值、最小值、最大值</span></div><div class="line">    <span class="keyword">val</span> totalContentSize = contentSizeRDD.sum()</div><div class="line">    <span class="keyword">val</span> totalCount = contentSizeRDD.count()</div><div class="line">    <span class="keyword">val</span> avgSize = <span class="number">1.0</span> * totalContentSize / totalCount</div><div class="line">    <span class="keyword">val</span> minSize = contentSizeRDD.min()</div><div class="line">    <span class="keyword">val</span> maxSize = contentSizeRDD.max()</div><div class="line"></div><div class="line">    <span class="comment">// 当RDD不使用的时候，进行unpersist</span></div><div class="line">    contentSizeRDD.unpersist()</div><div class="line"></div><div class="line">    <span class="comment">// 结果输出</span></div><div class="line">    println(<span class="string">s"ContentSize Avg：<span class="subst">$&#123;avgSize&#125;</span>, Min: <span class="subst">$&#123;minSize&#125;</span>, Max: <span class="subst">$&#123;maxSize&#125;</span>"</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 需求二：请各个不同返回值的出现的数据 ===&gt; wordCount程序</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    * A count of response code's returned.</div><div class="line">    * */</div><div class="line">    <span class="keyword">val</span> responseCodeResultRDD = apacheAccessLog</div><div class="line">      <span class="comment">// 提取需要的字段数据, 转换为key/value键值对，方便进行reduceByKey操作</span></div><div class="line">      <span class="comment">// 当连续出现map或者flatMap的时候，将多个map/flatMap进行合并</span></div><div class="line">      .map(log =&gt; (log.responseCode, <span class="number">1</span>))</div><div class="line">      <span class="comment">// 使用reduceByKey函数，按照key进行分组后，计算每个key出现的次数</span></div><div class="line">      .reduceByKey(_ + _)</div><div class="line"></div><div class="line">    <span class="comment">// 结果输出</span></div><div class="line">    println(<span class="string">s""</span><span class="string">"ResponseCode :$&#123;responseCodeResultRDD.collect().mkString("</span>,<span class="string">")&#125;"</span><span class="string">""</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 需求三：获取访问次数超过N次的IP地址</span></div><div class="line">    <span class="comment">// 需求三额外：对IP地址进行限制，部分黑名单IP地址不统计</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    * All IPAddresses that have accessed this server more than N times.</div><div class="line">    * 1. 计算IP地址出现的次数 ===&gt; WordCount程序</div><div class="line">    * 2. 数据过滤</div><div class="line">    * */</div><div class="line">    <span class="keyword">val</span> blackIP = <span class="type">Array</span>(<span class="string">"200-55-104-193.dsl.prima.net.ar"</span>, <span class="string">"10.0.0.153"</span>, <span class="string">"208-38-57-205.ip.cal.radiant.net"</span>)</div><div class="line">    <span class="comment">// 由于集合比较大，将集合的内容广播出去</span></div><div class="line">    <span class="keyword">val</span> broadCastIP = sc.broadcast(blackIP)</div><div class="line">    <span class="keyword">val</span> <span class="type">N</span> = <span class="number">10</span></div><div class="line">    <span class="keyword">val</span> ipAddressRDD = apacheAccessLog</div><div class="line">      <span class="comment">// 过滤IP地址在黑名单中的数据</span></div><div class="line">      .filter(log =&gt; !broadCastIP.value.contains(log.ipAddress))</div><div class="line">      <span class="comment">// 获取计算需要的IP地址数据，并将返回值转换为Key/Value键值对类型</span></div><div class="line">      .map(log =&gt; (log.ipAddress, <span class="number">1</span>L))</div><div class="line">      <span class="comment">// 使用reduceByKey函数进行聚合操作</span></div><div class="line">      .reduceByKey(_ + _)</div><div class="line">      <span class="comment">// 过滤数据，要求IP地址必须出现N次以上</span></div><div class="line">      .filter(tuple =&gt; tuple._2 &gt; <span class="type">N</span>)</div><div class="line">    <span class="comment">// 获取满足条件IP地址, 为了展示方便，将下面这行代码注释</span></div><div class="line">    <span class="comment">//      .map(tuple =&gt; tuple._1)</span></div><div class="line"></div><div class="line">    <span class="comment">// 结果输出</span></div><div class="line">    println(<span class="string">s""</span><span class="string">"IP Address :$&#123;ipAddressRDD.collect().mkString("</span>,<span class="string">")&#125;"</span><span class="string">""</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 需求四：获取访问次数最多的前K个endpoint的值 ==&gt; TopN</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    * The top endpoints requested by count.</div><div class="line">    * 1. 先计算出每个endpoint的出现次数</div><div class="line">    * 2. 再进行topK的一个获取操作，获取出现次数最多的前K个值</div><div class="line">    * */</div><div class="line">    <span class="keyword">val</span> <span class="type">K</span> = <span class="number">10</span></div><div class="line">    <span class="keyword">val</span> topKValues = apacheAccessLog</div><div class="line">      <span class="comment">// 获取计算需要的字段信息，并返回key/value键值对</span></div><div class="line">      .map(log =&gt; (log.endpoint, <span class="number">1</span>))</div><div class="line">      <span class="comment">// 获取每个endpoint对应的出现次数</span></div><div class="line">      .reduceByKey(_ + _)</div><div class="line">      <span class="comment">// 获取前10个元素, 而且使用我们自定义的排序类</span></div><div class="line">      .top(<span class="type">K</span>)(<span class="type">LogSortingUtil</span>.<span class="type">TupleOrdering</span>)</div><div class="line">    <span class="comment">// 如果只需要endpoint的值，不需要出现的次数，那么可以通过map函数进行转换</span></div><div class="line">    <span class="comment">//      .map(_._1)</span></div><div class="line"></div><div class="line">    <span class="comment">// 结果输出</span></div><div class="line">    println(<span class="string">s""</span><span class="string">"TopK values:$&#123;topKValues.mkString("</span>,<span class="string">")&#125;"</span><span class="string">""</span>)</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 对不在使用的rdd，去除cache</span></div><div class="line">    apacheAccessLog.unpersist()</div><div class="line"></div><div class="line">    <span class="comment">// ================日志分析具体代码==================</span></div><div class="line"></div><div class="line">    sc.stop()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="需要的辅助类一（返回匹配的日志）"><a href="#需要的辅助类一（返回匹配的日志）" class="headerlink" title="需要的辅助类一（返回匹配的日志）"></a>需要的辅助类一（返回匹配的日志）</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.util.matching.<span class="type">Regex</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * 64.242.88.10 - - [07/Mar/2004:16:05:49 -0800] "GET /twiki/bin/edit/Main/Double_bounce_sender?topicparent=Main.ConfigurationVariables HTTP/1.1" 401 12846</div><div class="line">  */</div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ApacheAccessLog</span>(<span class="params"></span></span></div><div class="line">                            ipAddress: <span class="type">String</span>, // <span class="type">IP</span>地址</div><div class="line">                            clientId: <span class="type">String</span>, // 客户端唯一标识符</div><div class="line">                            userId: <span class="type">String</span>, // 用户唯一标识符</div><div class="line">                            serverTime: <span class="type">String</span>, // 服务器时间</div><div class="line">                            method: <span class="type">String</span>, // 请求类型/方式</div><div class="line">                            endpoint: <span class="type">String</span>, // 请求的资源</div><div class="line">                            protocol: <span class="type">String</span>, // 请求的协议名称</div><div class="line">                            responseCode: <span class="type">Int</span>, // 请求返回值：比如：200、401</div><div class="line">                            contentSize: <span class="type">Long</span> // 返回的结果数据大小</div><div class="line">                          )</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * 64.242.88.10 - - [07/Mar/2004:16:05:49 -0800] "GET /twiki/bin/edit/Main/Double_bounce_sender?topicparent=Main.ConfigurationVariables HTTP/1.1" 401 12846</div><div class="line">  * Created by ibf on 01/15.</div><div class="line">  * 提供一些操作Apache Log的工具类供SparkCore使用</div><div class="line">  */</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">ApacheAccessLog</span> </span>&#123;</div><div class="line">  <span class="comment">// Apache日志的正则</span></div><div class="line">  <span class="keyword">val</span> <span class="type">PARTTERN</span>: <span class="type">Regex</span> =</div><div class="line">  <span class="string">""</span><span class="string">"^(\S+) (\S+) (\S+) \[([\w:/]+\s[+\-]\d&#123;4&#125;)\] "</span>(\<span class="type">S</span>+) (\<span class="type">S</span>+) (\<span class="type">S</span>+)<span class="string">" (\d&#123;3&#125;) (\d+)"</span><span class="string">""</span>.r</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 验证一下输入的数据是否符合给定的日志正则，如果符合返回true；否则返回false</div><div class="line">    *</div><div class="line">    * @param line</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isValidateLogLine</span></span>(line: <span class="type">String</span>): <span class="type">Boolean</span> = &#123;</div><div class="line">    <span class="keyword">val</span> options = <span class="type">PARTTERN</span>.findFirstMatchIn(line)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (options.isEmpty) &#123;</div><div class="line">      <span class="literal">false</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 解析输入的日志数据</div><div class="line">    *</div><div class="line">    * @param line</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parseLogLine</span></span>(line: <span class="type">String</span>): <span class="type">ApacheAccessLog</span> = &#123;</div><div class="line">    <span class="keyword">if</span> (!isValidateLogLine(line)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"参数格式异常"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 从line中获取匹配的数据</span></div><div class="line">    <span class="keyword">val</span> options = <span class="type">PARTTERN</span>.findFirstMatchIn(line)</div><div class="line"></div><div class="line">    <span class="comment">// 获取matcher</span></div><div class="line">    <span class="keyword">val</span> matcher = options.get</div><div class="line"></div><div class="line">    <span class="comment">// 构建返回值</span></div><div class="line">    <span class="type">ApacheAccessLog</span>(</div><div class="line">      matcher.group(<span class="number">1</span>), <span class="comment">// 获取匹配字符串中第一个小括号中的值</span></div><div class="line">      matcher.group(<span class="number">2</span>),</div><div class="line">      matcher.group(<span class="number">3</span>),</div><div class="line">      matcher.group(<span class="number">4</span>),</div><div class="line">      matcher.group(<span class="number">5</span>),</div><div class="line">      matcher.group(<span class="number">6</span>),</div><div class="line">      matcher.group(<span class="number">7</span>),</div><div class="line">      matcher.group(<span class="number">8</span>).toInt,</div><div class="line">      matcher.group(<span class="number">9</span>).toLong</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="需要的辅助类二（自定义的一个二元组的比较器，方便进行TopN）"><a href="#需要的辅助类二（自定义的一个二元组的比较器，方便进行TopN）" class="headerlink" title="需要的辅助类二（自定义的一个二元组的比较器，方便进行TopN）"></a>需要的辅助类二（自定义的一个二元组的比较器，方便进行TopN）</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">LogSortingUtil</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 自定义的一个二元组的比较器</div><div class="line">    */</div><div class="line">  <span class="class"><span class="keyword">object</span> <span class="title">TupleOrdering</span> <span class="keyword">extends</span> <span class="title">scala</span>.<span class="title">math</span>.<span class="title">Ordering</span>[(<span class="type">String</span>, <span class="type">Int</span>)] </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: (<span class="type">String</span>, <span class="type">Int</span>), y: (<span class="type">String</span>, <span class="type">Int</span>)): <span class="type">Int</span> = &#123;</div><div class="line">      <span class="comment">// 按照出现的次数进行比较，也就是按照二元组的第二个元素进行比较</span></div><div class="line">      x._2.compare(y._2)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="grey" size="1">注：此博客仅供博主自身复习用</font>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/20/Spark%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spark算子总结及案例</title>
      <link>http://Melodylican.github.io/2017/08/11/Spark%E7%AE%97%E5%AD%90%E6%80%BB%E7%BB%93%E5%8F%8A%E6%A1%88%E4%BE%8B/</link>
      <guid>http://Melodylican.github.io/2017/08/11/Spark%E7%AE%97%E5%AD%90%E6%80%BB%E7%BB%93%E5%8F%8A%E6%A1%88%E4%BE%8B/</guid>
      <pubDate>Thu, 10 Aug 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;spark算子大致上可分三大类算子&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;　　Value数据类型的Transformation算子，这种变换不触发提交作业，针对处理的数据项是Value型的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;　　Key-Value数据类型的Transformation算子，这种变换不触发提交作业，针对处理的数据项是Key-Value型的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;　　Action算子，这类算子会触发SparkContext提交作业。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>spark算子大致上可分三大类算子</strong>：</p>
<ol>
<li><p>　　Value数据类型的Transformation算子，这种变换不触发提交作业，针对处理的数据项是Value型的数据。</p>
</li>
<li><p>　　Key-Value数据类型的Transformation算子，这种变换不触发提交作业，针对处理的数据项是Key-Value型的数据。</p>
</li>
<li><p>　　Action算子，这类算子会触发SparkContext提交作业。</p>
<a id="more"></a>
</li>
</ol>
<h2 id="Value型Transformation算子"><a href="#Value型Transformation算子" class="headerlink" title="Value型Transformation算子"></a>Value型Transformation算子</h2><p><strong>1）map</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>, <span class="string">"salmon"</span>, <span class="string">"salmon"</span>, <span class="string">"rat"</span>, <span class="string">"elephant"</span>), <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> b = a.map(_.length)</div><div class="line"><span class="keyword">val</span> c = a.zip(b)</div><div class="line">c.collect</div><div class="line">res0: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((dog,<span class="number">3</span>), (salmon,<span class="number">6</span>), (salmon,<span class="number">6</span>), (rat,<span class="number">3</span>), (elephant,<span class="number">8</span>))</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%901.png" alt=""><br></center>

<p><strong>2）flatMap</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">10</span>, <span class="number">5</span>)</div><div class="line">a.flatMap(<span class="number">1</span> to _).collect</div><div class="line">res47: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line">sc.parallelize(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="number">2</span>).flatMap(x =&gt; <span class="type">List</span>(x, x, x)).collect</div><div class="line">res85: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%902.png" alt=""><br></center>


<p><strong>3）mapPartiions</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x  = sc.parallelize(<span class="number">1</span> to <span class="number">10</span>, <span class="number">3</span>)</div><div class="line">x.flatMap(<span class="type">List</span>.fill(scala.util.<span class="type">Random</span>.nextInt(<span class="number">10</span>))(_)).collect</div><div class="line"></div><div class="line">res1: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%903.png" alt=""><br></center>

<p><strong>4）glom（形成一个Array数组）</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">100</span>, <span class="number">3</span>)</div><div class="line">a.glom.collect</div><div class="line">res8: <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = <span class="type">Array</span>(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>), <span class="type">Array</span>(<span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>), <span class="type">Array</span>(<span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>))</div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%904.png" alt=""><br></center>


<p><strong>5）union</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">3</span>, <span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> b = sc.parallelize(<span class="number">5</span> to <span class="number">7</span>, <span class="number">1</span>)</div><div class="line">(a ++ b).collect</div><div class="line">res0: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%905.png" alt=""><br></center>


<p><strong>6）cartesian（笛卡尔操作）</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</div><div class="line"><span class="keyword">val</span> y = sc.parallelize(<span class="type">List</span>(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>))</div><div class="line">x.cartesian(y).collect</div><div class="line">res0: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((<span class="number">1</span>,<span class="number">6</span>), (<span class="number">1</span>,<span class="number">7</span>), (<span class="number">1</span>,<span class="number">8</span>), (<span class="number">1</span>,<span class="number">9</span>), (<span class="number">1</span>,<span class="number">10</span>), (<span class="number">2</span>,<span class="number">6</span>), (<span class="number">2</span>,<span class="number">7</span>), (<span class="number">2</span>,<span class="number">8</span>), (<span class="number">2</span>,<span class="number">9</span>), (<span class="number">2</span>,<span class="number">10</span>), (<span class="number">3</span>,<span class="number">6</span>), (<span class="number">3</span>,<span class="number">7</span>), (<span class="number">3</span>,<span class="number">8</span>), (<span class="number">3</span>,<span class="number">9</span>), (<span class="number">3</span>,<span class="number">10</span>), (<span class="number">4</span>,<span class="number">6</span>), (<span class="number">5</span>,<span class="number">6</span>), (<span class="number">4</span>,<span class="number">7</span>), (<span class="number">5</span>,<span class="number">7</span>), (<span class="number">4</span>,<span class="number">8</span>), (<span class="number">5</span>,<span class="number">8</span>), (<span class="number">4</span>,<span class="number">9</span>), (<span class="number">4</span>,<span class="number">10</span>), (<span class="number">5</span>,<span class="number">9</span>), (<span class="number">5</span>,<span class="number">10</span>))</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%906.png" alt=""><br></center>


<p><strong>7）groupBy（生成相应的key，相同的放在一起）</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">9</span>, <span class="number">3</span>)</div><div class="line">a.groupBy(x =&gt; &#123; <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) <span class="string">"even"</span> <span class="keyword">else</span> <span class="string">"odd"</span> &#125;).collect</div><div class="line">res42: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Seq</span>[<span class="type">Int</span>])] = <span class="type">Array</span>((even,<span class="type">ArrayBuffer</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)), (odd,<span class="type">ArrayBuffer</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)))</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%907.png" alt=""><br></center>


<p><strong>8）filter</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">10</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> b = a.filter(_ % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">b.collect</div><div class="line">res3: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%908.png" alt=""><br></center>


<p><strong>9）distinct（去重）</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"Gnu"</span>, <span class="string">"Cat"</span>, <span class="string">"Rat"</span>, <span class="string">"Dog"</span>, <span class="string">"Gnu"</span>, <span class="string">"Rat"</span>), <span class="number">2</span>)</div><div class="line">c.distinct.collect</div><div class="line">res6: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(<span class="type">Dog</span>, <span class="type">Gnu</span>, <span class="type">Cat</span>, <span class="type">Rat</span>)</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%909.png" alt=""><br></center>


<p><strong>10）subtract（去掉含有重复的项）</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">9</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> b = sc.parallelize(<span class="number">1</span> to <span class="number">3</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> c = a.subtract(b)</div><div class="line">c.collect</div><div class="line">res3: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>)</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9010.png" alt=""><br></center>


<p><strong>11）sample</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">10000</span>, <span class="number">3</span>)</div><div class="line">a.sample(<span class="literal">false</span>, <span class="number">0.1</span>, <span class="number">0</span>).count</div><div class="line">res24: <span class="type">Long</span> = <span class="number">960</span></div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9011.png" alt=""><br></center>

<p><strong>12）takesample</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = sc.parallelize(<span class="number">1</span> to <span class="number">1000</span>, <span class="number">3</span>)</div><div class="line">x.takeSample(<span class="literal">true</span>, <span class="number">100</span>, <span class="number">1</span>)</div><div class="line">res3: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">339</span>, <span class="number">718</span>, <span class="number">810</span>, <span class="number">105</span>, <span class="number">71</span>, <span class="number">268</span>, <span class="number">333</span>, <span class="number">360</span>, <span class="number">341</span>, <span class="number">300</span>, <span class="number">68</span>, <span class="number">848</span>, <span class="number">431</span>, <span class="number">449</span>, <span class="number">773</span>, <span class="number">172</span>, <span class="number">802</span>, <span class="number">339</span>, <span class="number">431</span>, <span class="number">285</span>, <span class="number">937</span>, <span class="number">301</span>, <span class="number">167</span>, <span class="number">69</span>, <span class="number">330</span>, <span class="number">864</span>, <span class="number">40</span>, <span class="number">645</span>, <span class="number">65</span>, <span class="number">349</span>, <span class="number">613</span>, <span class="number">468</span>, <span class="number">982</span>, <span class="number">314</span>, <span class="number">160</span>, <span class="number">675</span>, <span class="number">232</span>, <span class="number">794</span>, <span class="number">577</span>, <span class="number">571</span>, <span class="number">805</span>, <span class="number">317</span>, <span class="number">136</span>, <span class="number">860</span>, <span class="number">522</span>, <span class="number">45</span>, <span class="number">628</span>, <span class="number">178</span>, <span class="number">321</span>, <span class="number">482</span>, <span class="number">657</span>, <span class="number">114</span>, <span class="number">332</span>, <span class="number">728</span>, <span class="number">901</span>, <span class="number">290</span>, <span class="number">175</span>, <span class="number">876</span>, <span class="number">227</span>, <span class="number">130</span>, <span class="number">863</span>, <span class="number">773</span>, <span class="number">559</span>, <span class="number">301</span>, <span class="number">694</span>, <span class="number">460</span>, <span class="number">839</span>, <span class="number">952</span>, <span class="number">664</span>, <span class="number">851</span>, <span class="number">260</span>, <span class="number">729</span>, <span class="number">823</span>, <span class="number">880</span>, <span class="number">792</span>, <span class="number">964</span>, <span class="number">614</span>, <span class="number">821</span>, <span class="number">683</span>, <span class="number">364</span>, <span class="number">80</span>, <span class="number">875</span>, <span class="number">813</span>, <span class="number">951</span>, <span class="number">663</span>, <span class="number">344</span>, <span class="number">546</span>, <span class="number">918</span>, <span class="number">436</span>, <span class="number">451</span>, <span class="number">397</span>, <span class="number">670</span>, <span class="number">756</span>, <span class="number">512</span>, <span class="number">391</span>, <span class="number">70</span>, <span class="number">213</span>, <span class="number">896</span>, <span class="number">123</span>, <span class="number">858</span>)</div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9012.png" alt=""><br></center>



<p><strong>13）cache、persist</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"Gnu"</span>, <span class="string">"Cat"</span>, <span class="string">"Rat"</span>, <span class="string">"Dog"</span>, <span class="string">"Gnu"</span>, <span class="string">"Rat"</span>), <span class="number">2</span>)</div><div class="line">c.getStorageLevel</div><div class="line">res0: org.apache.spark.storage.<span class="type">StorageLevel</span> = <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">1</span>)</div><div class="line">c.cache</div><div class="line">c.getStorageLevel</div><div class="line">res2: org.apache.spark.storage.<span class="type">StorageLevel</span> = <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">1</span>)</div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9013.png" alt=""><br></center>

<h2 id="Key-Value型Transformation算子"><a href="#Key-Value型Transformation算子" class="headerlink" title="Key-Value型Transformation算子"></a>Key-Value型Transformation算子</h2><p><strong>1）mapValues</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>, <span class="string">"tiger"</span>, <span class="string">"lion"</span>, <span class="string">"cat"</span>, <span class="string">"panther"</span>, <span class="string">"eagle"</span>), <span class="number">2</span>)</div><div class="line"><span class="keyword">val</span> b = a.map(x =&gt; (x.length, x))</div><div class="line">b.mapValues(<span class="string">"x"</span> + _ + <span class="string">"x"</span>).collect</div><div class="line">res5: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">Array</span>((<span class="number">3</span>,xdogx), (<span class="number">5</span>,xtigerx), (<span class="number">4</span>,xlionx), (<span class="number">3</span>,xcatx), (<span class="number">7</span>,xpantherx), (<span class="number">5</span>,xeaglex))</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9014.png" alt=""><br></center>


<p><strong>2）combineByKey</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>,<span class="string">"cat"</span>,<span class="string">"gnu"</span>,<span class="string">"salmon"</span>,<span class="string">"rabbit"</span>,<span class="string">"turkey"</span>,<span class="string">"wolf"</span>,<span class="string">"bear"</span>,<span class="string">"bee"</span>), <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> b = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> c = b.zip(a)</div><div class="line"><span class="keyword">val</span> d = c.combineByKey(<span class="type">List</span>(_), (x:<span class="type">List</span>[<span class="type">String</span>], y:<span class="type">String</span>) =&gt; y :: x, (x:<span class="type">List</span>[<span class="type">String</span>], y:<span class="type">List</span>[<span class="type">String</span>]) =&gt; x ::: y)</div><div class="line">d.collect</div><div class="line">res16: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">List</span>[<span class="type">String</span>])] = <span class="type">Array</span>((<span class="number">1</span>,<span class="type">List</span>(cat, dog, turkey)), (<span class="number">2</span>,<span class="type">List</span>(gnu, rabbit, salmon, bee, bear, wolf)))</div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9015.png" alt=""><br></center>


<p><strong>3）reduceByKey</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"owl"</span>, <span class="string">"gnu"</span>, <span class="string">"ant"</span>), <span class="number">2</span>)</div><div class="line"><span class="keyword">val</span> b = a.map(x =&gt; (x.length, x))</div><div class="line">b.reduceByKey(_ + _).collect</div><div class="line">res86: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">Array</span>((<span class="number">3</span>,dogcatowlgnuant))</div><div class="line"></div><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>, <span class="string">"tiger"</span>, <span class="string">"lion"</span>, <span class="string">"cat"</span>, <span class="string">"panther"</span>, <span class="string">"eagle"</span>), <span class="number">2</span>)</div><div class="line"><span class="keyword">val</span> b = a.map(x =&gt; (x.length, x))</div><div class="line">b.reduceByKey(_ + _).collect</div><div class="line">res87: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">Array</span>((<span class="number">4</span>,lion), (<span class="number">3</span>,dogcat), (<span class="number">7</span>,panther), (<span class="number">5</span>,tigereagle))</div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9016.png" alt=""><br></center>


<p><strong>4）partitionBy</strong></p>
<p>（对RDD进行分区操作）</p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9017.png" alt=""><br></center>

<p><strong>5）cogroup</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>), <span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> b = a.map((_, <span class="string">"b"</span>))</div><div class="line"><span class="keyword">val</span> c = a.map((_, <span class="string">"c"</span>))</div><div class="line">b.cogroup(c).collect</div><div class="line">res7: <span class="type">Array</span>[(<span class="type">Int</span>, (<span class="type">Iterable</span>[<span class="type">String</span>], <span class="type">Iterable</span>[<span class="type">String</span>]))] = <span class="type">Array</span>(</div><div class="line">(<span class="number">2</span>,(<span class="type">ArrayBuffer</span>(b),<span class="type">ArrayBuffer</span>(c))),</div><div class="line">(<span class="number">3</span>,(<span class="type">ArrayBuffer</span>(b),<span class="type">ArrayBuffer</span>(c))),</div><div class="line">(<span class="number">1</span>,(<span class="type">ArrayBuffer</span>(b, b),<span class="type">ArrayBuffer</span>(c, c)))</div><div class="line">)</div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9018.png" alt=""><br></center>


<p><strong>6）join</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>, <span class="string">"salmon"</span>, <span class="string">"salmon"</span>, <span class="string">"rat"</span>, <span class="string">"elephant"</span>), <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> b = a.keyBy(_.length)</div><div class="line"><span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>,<span class="string">"cat"</span>,<span class="string">"gnu"</span>,<span class="string">"salmon"</span>,<span class="string">"rabbit"</span>,<span class="string">"turkey"</span>,<span class="string">"wolf"</span>,<span class="string">"bear"</span>,<span class="string">"bee"</span>), <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> d = c.keyBy(_.length)</div><div class="line">b.join(d).collect</div><div class="line"></div><div class="line">res0: <span class="type">Array</span>[(<span class="type">Int</span>, (<span class="type">String</span>, <span class="type">String</span>))] = <span class="type">Array</span>((<span class="number">6</span>,(salmon,salmon)), (<span class="number">6</span>,(salmon,rabbit)), (<span class="number">6</span>,(salmon,turkey)), (<span class="number">6</span>,(salmon,salmon)), (<span class="number">6</span>,(salmon,rabbit)), (<span class="number">6</span>,(salmon,turkey)), (<span class="number">3</span>,(dog,dog)), (<span class="number">3</span>,(dog,cat)), (<span class="number">3</span>,(dog,gnu)), (<span class="number">3</span>,(dog,bee)), (<span class="number">3</span>,(rat,dog)), (<span class="number">3</span>,(rat,cat)), (<span class="number">3</span>,(rat,gnu)), (<span class="number">3</span>,(rat,bee)))</div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9019.png" alt=""><br></center>


<p><strong>7）leftOutJoin</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>, <span class="string">"salmon"</span>, <span class="string">"salmon"</span>, <span class="string">"rat"</span>, <span class="string">"elephant"</span>), <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> b = a.keyBy(_.length)</div><div class="line"><span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>,<span class="string">"cat"</span>,<span class="string">"gnu"</span>,<span class="string">"salmon"</span>,<span class="string">"rabbit"</span>,<span class="string">"turkey"</span>,<span class="string">"wolf"</span>,<span class="string">"bear"</span>,<span class="string">"bee"</span>), <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> d = c.keyBy(_.length)</div><div class="line">b.leftOuterJoin(d).collect</div><div class="line"></div><div class="line">res1: <span class="type">Array</span>[(<span class="type">Int</span>, (<span class="type">String</span>, <span class="type">Option</span>[<span class="type">String</span>]))] = <span class="type">Array</span>((<span class="number">6</span>,(salmon,<span class="type">Some</span>(salmon))), (<span class="number">6</span>,(salmon,<span class="type">Some</span>(rabbit))), (<span class="number">6</span>,(salmon,<span class="type">Some</span>(turkey))), (<span class="number">6</span>,(salmon,<span class="type">Some</span>(salmon))), (<span class="number">6</span>,(salmon,<span class="type">Some</span>(rabbit))), (<span class="number">6</span>,(salmon,<span class="type">Some</span>(turkey))), (<span class="number">3</span>,(dog,<span class="type">Some</span>(dog))), (<span class="number">3</span>,(dog,<span class="type">Some</span>(cat))), (<span class="number">3</span>,(dog,<span class="type">Some</span>(gnu))), (<span class="number">3</span>,(dog,<span class="type">Some</span>(bee))), (<span class="number">3</span>,(rat,<span class="type">Some</span>(dog))), (<span class="number">3</span>,(rat,<span class="type">Some</span>(cat))), (<span class="number">3</span>,(rat,<span class="type">Some</span>(gnu))), (<span class="number">3</span>,(rat,<span class="type">Some</span>(bee))), (<span class="number">8</span>,(elephant,<span class="type">None</span>)))</div></pre></td></tr></table></figure>
<p><strong>8）rightOutJoin</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>, <span class="string">"salmon"</span>, <span class="string">"salmon"</span>, <span class="string">"rat"</span>, <span class="string">"elephant"</span>), <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> b = a.keyBy(_.length)</div><div class="line"><span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>,<span class="string">"cat"</span>,<span class="string">"gnu"</span>,<span class="string">"salmon"</span>,<span class="string">"rabbit"</span>,<span class="string">"turkey"</span>,<span class="string">"wolf"</span>,<span class="string">"bear"</span>,<span class="string">"bee"</span>), <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> d = c.keyBy(_.length)</div><div class="line">b.rightOuterJoin(d).collect</div><div class="line"></div><div class="line">res2: <span class="type">Array</span>[(<span class="type">Int</span>, (<span class="type">Option</span>[<span class="type">String</span>], <span class="type">String</span>))] = <span class="type">Array</span>((<span class="number">6</span>,(<span class="type">Some</span>(salmon),salmon)), (<span class="number">6</span>,(<span class="type">Some</span>(salmon),rabbit)), (<span class="number">6</span>,(<span class="type">Some</span>(salmon),turkey)), (<span class="number">6</span>,(<span class="type">Some</span>(salmon),salmon)), (<span class="number">6</span>,(<span class="type">Some</span>(salmon),rabbit)), (<span class="number">6</span>,(<span class="type">Some</span>(salmon),turkey)), (<span class="number">3</span>,(<span class="type">Some</span>(dog),dog)), (<span class="number">3</span>,(<span class="type">Some</span>(dog),cat)), (<span class="number">3</span>,(<span class="type">Some</span>(dog),gnu)), (<span class="number">3</span>,(<span class="type">Some</span>(dog),bee)), (<span class="number">3</span>,(<span class="type">Some</span>(rat),dog)), (<span class="number">3</span>,(<span class="type">Some</span>(rat),cat)), (<span class="number">3</span>,(<span class="type">Some</span>(rat),gnu)), (<span class="number">3</span>,(<span class="type">Some</span>(rat),bee)), (<span class="number">4</span>,(<span class="type">None</span>,wolf)), (<span class="number">4</span>,(<span class="type">None</span>,bear)))</div></pre></td></tr></table></figure>
<h2 id="Actions算子"><a href="#Actions算子" class="headerlink" title="Actions算子"></a>Actions算子</h2><p><strong>1）foreach</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"tiger"</span>, <span class="string">"lion"</span>, <span class="string">"gnu"</span>, <span class="string">"crocodile"</span>, <span class="string">"ant"</span>, <span class="string">"whale"</span>, <span class="string">"dolphin"</span>, <span class="string">"spider"</span>), <span class="number">3</span>)</div><div class="line">c.foreach(x =&gt; println(x + <span class="string">"s are yummy"</span>))</div><div class="line">lions are yummy</div><div class="line">gnus are yummy</div><div class="line">crocodiles are yummy</div><div class="line">ants are yummy</div><div class="line">whales are yummy</div><div class="line">dolphins are yummy</div><div class="line">spiders are yummy</div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9020.png" alt=""><br></center>

<p><strong>2）saveAsTextFile</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">10000</span>, <span class="number">3</span>)</div><div class="line">a.saveAsTextFile(<span class="string">"mydata_a"</span>)</div><div class="line"><span class="number">14</span>/<span class="number">04</span>/<span class="number">03</span> <span class="number">21</span>:<span class="number">11</span>:<span class="number">36</span> <span class="type">INFO</span> <span class="type">FileOutputCommitter</span>: <span class="type">Saved</span> output of task <span class="symbol">'attempt_201404032111_0000_m_000002_7</span>1' to file:/home/cloudera/<span class="type">Documents</span>/spark<span class="number">-0.9</span><span class="number">.0</span>-incubating-bin-cdh4/bin/mydata_a</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9021.png" alt=""><br></center>


<p><strong>3）saveAsObjectFile</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = sc.parallelize(<span class="number">1</span> to <span class="number">100</span>, <span class="number">3</span>)</div><div class="line">x.saveAsObjectFile(<span class="string">"objFile"</span>)</div><div class="line"><span class="keyword">val</span> y = sc.objectFile[<span class="type">Int</span>](<span class="string">"objFile"</span>)</div><div class="line">y.collect</div><div class="line">res52: <span class="type">Array</span>[<span class="type">Int</span>] =  <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>)</div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9022.png" alt=""><br></center>

<p><strong>4）collect</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"Gnu"</span>, <span class="string">"Cat"</span>, <span class="string">"Rat"</span>, <span class="string">"Dog"</span>, <span class="string">"Gnu"</span>, <span class="string">"Rat"</span>), <span class="number">2</span>)</div><div class="line">c.collect</div><div class="line">res29: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(<span class="type">Gnu</span>, <span class="type">Cat</span>, <span class="type">Rat</span>, <span class="type">Dog</span>, <span class="type">Gnu</span>, <span class="type">Rat</span>)</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9023.png" alt=""><br></center>


<p><strong>5）collectAsMap</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>), <span class="number">1</span>)</div><div class="line"><span class="keyword">val</span> b = a.zip(a)</div><div class="line">b.collectAsMap</div><div class="line">res1: scala.collection.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">2</span>, <span class="number">1</span> -&gt; <span class="number">1</span>, <span class="number">3</span> -&gt; <span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9024.png" alt=""><br></center>

<p><strong>6）reduceByKeyLocally</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"owl"</span>, <span class="string">"gnu"</span>, <span class="string">"ant"</span>), <span class="number">2</span>)</div><div class="line"><span class="keyword">val</span> b = a.map(x =&gt; (x.length, x))</div><div class="line">b.reduceByKey(_ + _).collect</div><div class="line">res86: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">Array</span>((<span class="number">3</span>,dogcatowlgnuant))</div></pre></td></tr></table></figure></p>
<p><strong>7）lookup</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="string">"dog"</span>, <span class="string">"tiger"</span>, <span class="string">"lion"</span>, <span class="string">"cat"</span>, <span class="string">"panther"</span>, <span class="string">"eagle"</span>), <span class="number">2</span>)</div><div class="line"><span class="keyword">val</span> b = a.map(x =&gt; (x.length, x))</div><div class="line">b.lookup(<span class="number">5</span>)</div><div class="line">res0: <span class="type">Seq</span>[<span class="type">String</span>] = <span class="type">WrappedArray</span>(tiger, eagle)</div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9025.png" alt=""><br></center>

<p><strong>8）count</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> c = sc.parallelize(<span class="type">List</span>(<span class="string">"Gnu"</span>, <span class="string">"Cat"</span>, <span class="string">"Rat"</span>, <span class="string">"Dog"</span>), <span class="number">2</span>)</div><div class="line">c.count</div><div class="line">res2: <span class="type">Long</span> = <span class="number">4</span></div></pre></td></tr></table></figure></p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9026.png" alt=""><br></center>


<p><strong>9）top</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> c = sc.parallelize(<span class="type">Array</span>(<span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>), <span class="number">2</span>)</div><div class="line">c.top(<span class="number">2</span>)</div><div class="line">res28: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">9</span>, <span class="number">8</span>)</div></pre></td></tr></table></figure></p>
<p><strong>10）reduce</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">100</span>, <span class="number">3</span>)</div><div class="line">a.reduce(_ + _)</div><div class="line">res41: <span class="type">Int</span> = <span class="number">5050</span></div></pre></td></tr></table></figure>
<p><strong>11）fold</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="number">3</span>)</div><div class="line">a.fold(<span class="number">0</span>)(_ + _)</div><div class="line">res59: <span class="type">Int</span> = <span class="number">6</span></div></pre></td></tr></table></figure>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E7%AE%97%E5%AD%9027.png" alt=""><br></center>


<p><strong>12）aggregate</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">val</span> z = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>), <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">// lets first print out the contents of the RDD with partition labels</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span></span>(index: <span class="type">Int</span>, iter: <span class="type">Iterator</span>[(<span class="type">Int</span>)]) : <span class="type">Iterator</span>[<span class="type">String</span>] = &#123;</div><div class="line">  iter.toList.map(x =&gt; <span class="string">"[partID:"</span> +  index + <span class="string">", val: "</span> + x + <span class="string">"]"</span>).iterator</div><div class="line">&#125;</div><div class="line"></div><div class="line">z.mapPartitionsWithIndex(myfunc).collect</div><div class="line">res28: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>([partID:<span class="number">0</span>, <span class="keyword">val</span>: <span class="number">1</span>], [partID:<span class="number">0</span>, <span class="keyword">val</span>: <span class="number">2</span>], [partID:<span class="number">0</span>, <span class="keyword">val</span>: <span class="number">3</span>], [partID:<span class="number">1</span>, <span class="keyword">val</span>: <span class="number">4</span>], [partID:<span class="number">1</span>, <span class="keyword">val</span>: <span class="number">5</span>], [partID:<span class="number">1</span>, <span class="keyword">val</span>: <span class="number">6</span>])</div><div class="line"></div><div class="line">z.aggregate(<span class="number">0</span>)(math.max(_, _), _ + _)</div><div class="line">res40: <span class="type">Int</span> = <span class="number">9</span></div></pre></td></tr></table></figure>
<p>参考：<a href="http://homepage.cs.latrobe.edu.au/zhe/ZhenHeSparkRDDAPIExamples.html" target="_blank" rel="external">http://homepage.cs.latrobe.edu.au/zhe/ZhenHeSparkRDDAPIExamples.html</a></p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/11/Spark%E7%AE%97%E5%AD%90%E6%80%BB%E7%BB%93%E5%8F%8A%E6%A1%88%E4%BE%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java虚拟机之JVM运行时数据区</title>
      <link>http://Melodylican.github.io/2017/08/09/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</link>
      <guid>http://Melodylican.github.io/2017/08/09/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</guid>
      <pubDate>Tue, 08 Aug 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java虚拟机在执行Java程序时会将其所管理的内存区域分成几个不同的部分，这几个部分的生命周期以及作用都各自不同，这些区域分别为：方法区（Method Area）、堆（Heap）、虚拟栈（VM Stack）、本地方法栈（Native Method Stack）、程序计数器（Program Counter Register），下面分别详细介绍一下。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java虚拟机在执行Java程序时会将其所管理的内存区域分成几个不同的部分，这几个部分的生命周期以及作用都各自不同，这些区域分别为：方法区（Method Area）、堆（Heap）、虚拟栈（VM Stack）、本地方法栈（Native Method Stack）、程序计数器（Program Counter Register），下面分别详细介绍一下。<br><a id="more"></a></p>
<h2 id="运行时线程之间相互隔离的数据区域"><a href="#运行时线程之间相互隔离的数据区域" class="headerlink" title="运行时线程之间相互隔离的数据区域"></a>运行时线程之间相互隔离的数据区域</h2><ul>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>程序计数器</li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈属于线程私有，其生命周期与线程保持一致。VM Stack描述的是一个Java方法执行 时的内存模型。每个方法在执行时都会创建一个栈帧，这个栈帧会存储方法的局部变量表、操作数栈、方法出口等信息。一个Java方法从运行到结束，对应于一个栈帧从虚拟机栈入栈到出栈的过程。这里的局部变量表存放了各种基本类型（比如int、float等）、还有对象引用。Java方法运行时，局部变量表是不会改变的，因为VM Stack中需要对正要运行的方法创建多大空间的栈帧是确定的。但如果线程请求的栈帧空间大于VM Stack时就会抛出OOM异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与VM Stack的作用基本相同，部分虚拟机并没有按照Java虚拟机规范分开两者，像HotSpot虚拟机就将二者合起来。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器属于线程私有空间，可以认为程序计数器就是一个当前正在执行的字节码的行号指示器，虚拟机的字节码解释器就是通过改变这个计数器的值来选择吓一条需要执行的指令，比如分支语句、循环语句、跳转语句、异常等等都需要依赖程序计数器完成。不同于操作系统的多线程模型，JVM的多线程是依赖于抢占CPU执行时间来完成，也就是说任何时刻，一个CPU核心只会执行一个线程中的指令，因此，为了线程切换之后程序能回到正确的指令处理位置，每个线程都需要一个独立的程序计数器。如果程序正在执行的是一个Java方法，则程序计数器记录的是正在执行的字节码的指令地址，如果正在执行的是一个native方法呢，其值为空（Undefined）。Java虚拟机规范里面，程序计数器是唯一一个不会有OOM的区域。</p>
<h2 id="运行时线程之间共享的数据区域"><a href="#运行时线程之间共享的数据区域" class="headerlink" title="运行时线程之间共享的数据区域"></a>运行时线程之间共享的数据区域</h2><ul>
<li>方法区</li>
<li>堆</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存储已经被虚拟机加载的类信息、常量、静态变量等。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java Heap 是虚拟机管理的内存区域中最大的一块了。Java堆在虚拟机启动时创建，并被所有线程所共享。这个Java堆呢，只用于存放对象实例，理论上所有的对象实例都在这里分配内存。因为堆区是垃圾收集器所关注的主要区域，而现在的很多垃圾收集器都采用分代收集算法，所有Java堆还可以细分为新生代和老年代。</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/09/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/#disqus_thread</comments>
    </item>
    
    <item>
      <title>集中式内存缓存Guava Cache</title>
      <link>http://Melodylican.github.io/2017/08/08/%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Guava_Cache/</link>
      <guid>http://Melodylican.github.io/2017/08/08/%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Guava_Cache/</guid>
      <pubDate>Mon, 07 Aug 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;缓存的主要作用是暂时在内存中保存业务系统的数据处理结果，并且等待下次访问使用。在日长开发有很多场合，有一些数据量不是很大，不会经常改动，并且访问非常频繁。但是由于受限于硬盘IO的性能或者远程网络等原因获取可能非常的费时。会导致我们的程序非常缓慢，这在某些业务上是不能忍的！而缓存正是解决这类问题的神器！&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>缓存的主要作用是暂时在内存中保存业务系统的数据处理结果，并且等待下次访问使用。在日长开发有很多场合，有一些数据量不是很大，不会经常改动，并且访问非常频繁。但是由于受限于硬盘IO的性能或者远程网络等原因获取可能非常的费时。会导致我们的程序非常缓慢，这在某些业务上是不能忍的！而缓存正是解决这类问题的神器！<br><a id="more"></a></p>
<p><center><br><img src="http://ojwkevhas.bkt.clouddn.com/guava_cache.png" alt=""><br></center><br>当然也并不是说你用了缓存你的系统就一定会变快，建议在用之前看一下<a href="http://kb.cnblogs.com/page/138696/" target="_blank" rel="external">使用缓存的9大误区(上)</a> <a href="http://kb.cnblogs.com/page/144396/" target="_blank" rel="external">使用缓存的9大误区(下)</a></p>
<p>缓存在很多系统和架构中都用广泛的应用,例如：</p>
<ul>
<li>CPU缓存</li>
<li>操作系统缓存</li>
<li>HTTP缓存</li>
<li>数据库缓存</li>
<li>静态文件缓存</li>
<li>本地缓存</li>
<li>分布式缓存</li>
</ul>
<p>可以说在计算机和网络领域，缓存是无处不在的。可以这么说，只要有硬件性能不对等，涉及到网络传输的地方都会有缓存的身影。</p>
<p>缓存总体可分为两种 集中式缓存 和 分布式缓存</p>
<p>“集中式缓存”与”分布式缓存”的区别其实就在于“集中”与”非集中”的概念，其对象可能是服务器、内存条、硬盘等。比如：</p>
<h3 id="1-服务器版本："><a href="#1-服务器版本：" class="headerlink" title="1.服务器版本："></a>1.服务器版本：</h3><ul>
<li>缓存集中在一台服务器上，为集中式缓存。</li>
<li>缓存分散在不同的服务器上，为分布式缓存。</li>
</ul>
<h3 id="2-内存条版本："><a href="#2-内存条版本：" class="headerlink" title="2.内存条版本："></a>2.内存条版本：</h3><ul>
<li>缓存集中在一台服务器的一条内存条上，为集中式缓存。</li>
<li>缓存分散在一台服务器的不同内存条上，为分布式缓存。</li>
</ul>
<h3 id="3-硬盘版本："><a href="#3-硬盘版本：" class="headerlink" title="3.硬盘版本："></a>3.硬盘版本：</h3><ul>
<li>缓存集中在一台服务器的一个硬盘上，为集中式缓存。</li>
<li>缓存分散在一台服务器的不同硬盘上，为分布式缓存。<br>想了解分布式缓存可以看一下<a href="http://os.51cto.com/art/201306/397999.htm" target="_blank" rel="external">浅谈分布式缓存那些事儿</a>。</li>
</ul>
<p>这是几个当前比较流行的java 分布式缓存框架<a href="http://developer.51cto.com/art/201411/457423.htm" target="_blank" rel="external">5个强大的Java分布式缓存框架推荐</a>。</p>
<p>而我们今天要讲的是集中式内存缓存guava cache,这是当前我们项目正在用的缓存工具，研究一下感觉还蛮好用的。当然也有很多其他工具，还是看个人喜欢。oschina上面也有很多类似开源的<a href="http://www.oschina.net/project/tag/132/cachesystem?sort=view&amp;lang=19&amp;os=0" target="_blank" rel="external">java缓存框架</a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Guava Cache与ConcurrentMap很相似，但也不完全一样。最基本的区别是ConcurrentMap会一直保存所有添加的元素，直到显式地移除。相对地，Guava Cache为了限制内存占用，通常都设定为自动回收元素。在某些场景下，尽管LoadingCache 不回收元素，它也是很有用的，因为它会自动加载缓存。</p>
<p>guava cache 加载缓存主要有两种方式:</p>
<ol>
<li>cacheLoader</li>
<li>callable callback</li>
</ol>
<h3 id="cacheLoader"><a href="#cacheLoader" class="headerlink" title="cacheLoader"></a>cacheLoader</h3><p>创建自己的CacheLoader通常只需要简单地实现V load(K key) throws Exception方法.</p>
<p>cacheLoader方式实现实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">LoadingCache&lt;Key, Value&gt; cache = CacheBuilder.newBuilder()</div><div class="line">       .build(</div><div class="line">           <span class="keyword">new</span> CacheLoader&lt;Key, Value&gt;() &#123;</div><div class="line">             <span class="function"><span class="keyword">public</span> Value <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> AnyException </span>&#123;</div><div class="line">               <span class="keyword">return</span> createValue(key);</div><div class="line">             &#125;</div><div class="line">           &#125;);</div><div class="line">...</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">return</span> cache.get(key);</div><div class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> OtherException(e.getCause());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从LoadingCache查询的正规方式是使用get(K)方法。这个方法要么返回已经缓存的值，要么使用CacheLoader向缓存原子地加载新值（通过load(String key) 方法加载）。由于CacheLoader可能抛出异常，LoadingCache.get(K)也声明抛出ExecutionException异常。如果你定义的CacheLoader没有声明任何检查型异常，则可以通过getUnchecked(K)查找缓存；但必须注意，一旦CacheLoader声明了检查型异常，就不可以调用getUnchecked(K)。</p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>这种方式不需要在创建的时候指定load方法，但是需要在get的时候实现一个Callable匿名内部类。</p>
<p>Callable方式实现实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Cache&lt;Key, Value&gt; cache = CacheBuilder.newBuilder()</div><div class="line">    .build(); <span class="comment">// look Ma, no CacheLoader</span></div><div class="line">...</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="comment">// If the key wasn't in the "easy to compute" group, we need to</span></div><div class="line">  <span class="comment">// do things the hard way.</span></div><div class="line">  cache.get(key, <span class="keyword">new</span> Callable&lt;Value&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> AnyException </span>&#123;</div><div class="line">      <span class="keyword">return</span> doThingsTheHardWay(key);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> OtherException(e.getCause());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而如果加上现在java8里面的Lambda表达式会看起来舒服很多<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   cache.get(key,()-&gt;&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;);</div><div class="line"> &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">   e.printStackTrace();</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>所有类型的Guava Cache，不管有没有自动加载功能，都支持get(K, Callable<v>)方法。这个方法返回缓存中相应的值，或者用给定的Callable运算并把结果加入到缓存中。在整个加载方法完成前，缓存项相关的可观察状态都不会更改。这个方法简便地实现了模式”如果有缓存则返回；否则运算、缓存、然后返回”。</v></p>
<p>当然除了上面那种被动的加载，它还提供了主动加载的方法cache.put(key, value)，这会直接覆盖掉给定键之前映射的值。使用Cache.asMap()视图提供的任何方法也能修改缓存。但请注意，asMap视图的任何方法都不能保证缓存项被原子地加载到缓存中。进一步说，asMap视图的原子运算在Guava Cache的原子加载范畴之外，所以相比于Cache.asMap().putIfAbsent(K,V)，Cache.get(K, Callable<v>) 应该总是优先使用。</v></p>
<h2 id="缓存回收"><a href="#缓存回收" class="headerlink" title="缓存回收"></a>缓存回收</h2><p>上面有提到 Guava Cache与ConcurrentMap 不一样的地方在于 guava cache可以自动回收元素，这在某种情况下可以更好优化资源被浪费的情况。</p>
<h3 id="基于容量的回收"><a href="#基于容量的回收" class="headerlink" title="基于容量的回收"></a>基于容量的回收</h3><p>当缓存设置CacheBuilder.maximumSize(size)。这个size是指具体缓存项目的数量而不是内存的大小。而且并不是说数量大于size才会回收，而是接近size就回收。</p>
<h3 id="定时回收"><a href="#定时回收" class="headerlink" title="定时回收"></a>定时回收</h3><ul>
<li>expireAfterAccess(long, TimeUnit)：缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。</li>
<li>expireAfterWrite(long, TimeUnit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回 收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。</li>
</ul>
<p>guava cache 还提供一个Ticker方法来设置缓存失效的具体时间精度为纳秒级。</p>
<h3 id="基于引用的回收"><a href="#基于引用的回收" class="headerlink" title="基于引用的回收"></a>基于引用的回收</h3><p>通过使用弱引用的键、或弱引用的值、或软引用的值，Guava Cache可以把缓存设置为允许垃圾回收：</p>
<ul>
<li>CacheBuilder.weakKeys()：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（==），使用弱引用键的缓存用==而不是equals比较键。</li>
<li>CacheBuilder.weakValues()：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（==），使用弱引用值的缓存用==而不是equals比较值。</li>
<li>CacheBuilder.softValues()：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。考虑到使用软引用的性能影响，我们通常建议使用更有性能预测性的缓存大小限定（见上文，基于容量回收）。使用软引用值的缓存同样用==而不是equals比较值。</li>
</ul>
<h3 id="显式清除"><a href="#显式清除" class="headerlink" title="显式清除"></a>显式清除</h3><p>任何时候，你都可以显式地清除缓存项，而不是等到它被回收：</p>
<ul>
<li>个别清除：Cache.invalidate(key)</li>
<li>批量清除：Cache.invalidateAll(keys)</li>
<li>清除所有缓存项：Cache.invalidateAll()</li>
</ul>
<p>这里说一个小技巧，由于guava cache是存在就取不存在就加载的机制，我们可以对缓存数据有修改的地方显示的把它清除掉，然后再有任务去取的时候就会去数据源重新加载，这样就可以最大程度上保证获取缓存的数据跟数据源是一致的。</p>
<h3 id="移除监听器"><a href="#移除监听器" class="headerlink" title="移除监听器"></a>移除监听器</h3><p>不要被名字所迷惑，这里指的是移除缓存的时候所触发的监听器。</p>
<p>请注意，RemovalListener抛出的任何异常都会在记录到日志后被丢弃[swallowed]。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LoadingCache&lt;K , V&gt; cache = CacheBuilder</div><div class="line">   .newBuilder()</div><div class="line">   .removalListener(<span class="keyword">new</span> RemovalListener&lt;K, V&gt;()&#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;K, V&gt; notification)</span> </span>&#123;</div><div class="line">       System.out.println(notification.getKey()+<span class="string">"被移除"</span>);</div><div class="line">     &#125;</div><div class="line">   &#125;)</div></pre></td></tr></table></figure></p>
<p><strong>Lambda的写法</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LoadingCache&lt;K , V&gt; cache = CacheBuilder</div><div class="line">   .newBuilder()</div><div class="line">   .removalListener((notification)-&gt;&#123;</div><div class="line">     System.out.println(notification.getKey()+<span class="string">"已移除"</span>);</div><div class="line">   &#125;)</div></pre></td></tr></table></figure></p>
<p><strong>警告</strong>：默认情况下，监听器方法是在移除缓存时同步调用的。因为缓存的维护和请求响应通常是同时进行的，代价高昂的监听器方法在同步模式下会拖慢正常的缓存请求。在这种情况下，你可以使用RemovalListeners.asynchronous(RemovalListener, Executor)把监听器装饰为异步操作。</p>
<p>这里提一下guava cache的自动回收，并不是缓存项过期起马上清理掉，而是在读或写的时候做少量的维护工作，这样做的原因在于：如果要自动地持续清理缓存，就必须有一个线程，这个线程会和用户操作竞争共享锁。此外，某些环境下线程创建可能受限制，这样CacheBuilder就不可用了。</p>
<p>相反，我们把选择权交到你手里。如果你的缓存是高吞吐的，那就无需担心缓存的维护和清理等工作。如果你的缓存只会偶尔有写操作，而你又不想清理工作阻碍了读操作，那么可以创建自己的维护线程，以固定的时间间隔调用Cache.cleanUp()。ScheduledExecutorService可以帮助你很好地实现这样的定时调度。</p>
<h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p>guava cache 除了回收还提供一种刷新机制LoadingCache.refresh(K)，他们的的区别在于，guava cache 在刷新时，其他线程可以继续获取它的旧值。这在某些情况是非常友好的。而回收的话就必须等新值加载完成以后才能继续读取。而且刷新是可以异步进行的。</p>
<p>如果刷新过程抛出异常，缓存将保留旧值，而异常会在记录到日志后被丢弃[swallowed]。<br>重载CacheLoader.reload(K, V)可以扩展刷新时的行为，这个方法允许开发者在计算新值时使用旧的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//有些键不需要刷新，并且我们希望刷新是异步完成的</span></div><div class="line">LoadingCache&lt;Key, Value&gt; graphs = CacheBuilder.newBuilder()</div><div class="line">       .maximumSize(<span class="number">1000</span>)</div><div class="line">       .refreshAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</div><div class="line">       .build(</div><div class="line">           <span class="keyword">new</span> CacheLoader&lt;Key, Value&gt;() &#123;</div><div class="line">             <span class="function"><span class="keyword">public</span> Graph <span class="title">load</span><span class="params">(Key key)</span> </span>&#123; <span class="comment">// no checked exception</span></div><div class="line">               <span class="keyword">return</span> getValue(key);</div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="function"><span class="keyword">public</span> ListenableFuture&lt;Value&gt; <span class="title">reload</span><span class="params">(<span class="keyword">final</span> Key key, Value value)</span> </span>&#123;</div><div class="line">               <span class="keyword">if</span> (neverNeedsRefresh(key)) &#123;</div><div class="line">                 <span class="keyword">return</span> Futures.immediateFuture(value);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                 <span class="comment">// asynchronous!</span></div><div class="line">                 ListenableFutureTask&lt;Value&gt; task = ListenableFutureTask.create(<span class="keyword">new</span> Callable&lt;Value&gt;() &#123;</div><div class="line">                   <span class="function"><span class="keyword">public</span> Graph <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                     <span class="keyword">return</span> getValue(key);</div><div class="line">                   &#125;</div><div class="line">                 &#125;);</div><div class="line">                 executor.execute(task);</div><div class="line">                 <span class="keyword">return</span> task;</div><div class="line">               &#125;</div><div class="line">             &#125;</div><div class="line">           &#125;);</div></pre></td></tr></table></figure></p>
<p>CacheBuilder.refreshAfterWrite(long, TimeUnit)可以为缓存增加自动定时刷新功能。和expireAfterWrite相反，refreshAfterWrite通过定时刷新可以让缓存项保持可用，但请注意：缓存项只有在被检索时才会真正刷新（如果CacheLoader.refresh实现为异步，那么检索不会被刷新拖慢）。因此，如果你在缓存上同时声明expireAfterWrite和refreshAfterWrite，缓存并不会因为刷新盲目地定时重置，如果缓存项没有被检索，那刷新就不会真的发生，缓存项在过期时间后也变得可以回收。</p>
<h2 id="asMap视图"><a href="#asMap视图" class="headerlink" title="asMap视图"></a>asMap视图</h2><p>asMap视图提供了缓存的ConcurrentMap形式，但asMap视图与缓存的交互需要注意：</p>
<ul>
<li>cache.asMap()包含当前所有加载到缓存的项。因此相应地，cache.asMap().keySet()包含当前所有已加载键;</li>
<li>asMap().get(key)实质上等同于cache.getIfPresent(key)，而且不会引起缓存项的加载。这和Map的语义约定一致。</li>
<li>所有读写操作都会重置相关缓存项的访问时间，包括Cache.asMap().get(Object)方法和Cache.asMap().put(K, V)方法，但不包括Cache.asMap().containsKey(Object)方法，也不包括在Cache.asMap()的集合视图上的操作。比如，遍历Cache.asMap().entrySet()不会重置缓存项的读取时间。</li>
</ul>
<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>guava cache为我们实现统计功能，这在其它缓存工具里面还是很少有的。</p>
<ul>
<li>CacheBuilder.recordStats()用来开启Guava Cache的统计功能。统计打开后， Cache.stats()方法会返回CacheStats对象以提供如下统计信息： </li>
<li>hitRate()：缓存命中率；</li>
<li>averageLoadPenalty()：加载新值的平均时间，单位为纳秒；</li>
<li>evictionCount()：缓存项被回收的总数，不包括显式清除。</li>
</ul>
<p>此外，还有其他很多统计信息。这些统计信息对于调整缓存设置是至关重要的，在性能要求高的应用中我们建议密切关注这些数据， 这里我们就不一一介绍了。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>缓存虽然是个好东西，但是一定不能滥用，一定要根据自己系统的需求来妥善抉择。<br>当然 guava 除了cache这块还有很多其它非常有用的工具。</p>
<font color="grey" size="1">注：本文参考：<a href="https://github.com/google/guava/wiki/CachesExplained" target="_blank" rel="external">https://github.com/google/guava/wiki/CachesExplained</a></font>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/08/%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98Guava_Cache/#disqus_thread</comments>
    </item>
    
    <item>
      <title>那些忽略的jdk特性</title>
      <link>http://Melodylican.github.io/2017/08/07/%E4%BD%BF%E7%94%A8java8%E5%90%8E%E9%82%A3%E4%BA%9B%E8%A2%AB%E6%9B%BE%E7%BB%8F%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E7%89%B9%E6%80%A7/</link>
      <guid>http://Melodylican.github.io/2017/08/07/%E4%BD%BF%E7%94%A8java8%E5%90%8E%E9%82%A3%E4%BA%9B%E8%A2%AB%E6%9B%BE%E7%BB%8F%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E7%89%B9%E6%80%A7/</guid>
      <pubDate>Sun, 06 Aug 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;虽然我们开始了Java8的旅程，但是很多人直接从java6上手了java8，也许有一些JDK7的特性你还不知道，在本章节中带你回顾一下我们忘记了的那些特性。&lt;br&gt;尽管我们不能将所有特性都讲一遍，挑出常用的核心特性拎出来一起学习。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>虽然我们开始了Java8的旅程，但是很多人直接从java6上手了java8，也许有一些JDK7的特性你还不知道，在本章节中带你回顾一下我们忘记了的那些特性。<br>尽管我们不能将所有特性都讲一遍，挑出常用的核心特性拎出来一起学习。<br><a id="more"></a></p>
<h2 id="异常改进"><a href="#异常改进" class="headerlink" title="异常改进"></a>异常改进</h2><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>这个特性是在JDK7种出现的，我们在之前操作一个流对象的时候大概是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 使用流对象</span></div><div class="line">    stream.read();</div><div class="line">    stream.write();</div><div class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    <span class="comment">// 处理异常</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 关闭流资源</span></div><div class="line">    <span class="keyword">if</span>(stream != <span class="keyword">null</span>)&#123;</div><div class="line">        stream.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样无疑有些繁琐，而且finally块还有可能抛出异常。在JDK7种提出了try-with-resources机制，<br>它规定你操作的类只要是实现了AutoCloseable接口就可以在try语句块退出的时候自动调用close方法关闭流资源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryWithResources</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">try</span>( InputStream ins = <span class="keyword">new</span> FileInputStream(<span class="string">"/home/biezhi/a.txt"</span>) )&#123;</div><div class="line">        <span class="keyword">char</span> charStr = (<span class="keyword">char</span>) ins.read();</div><div class="line">        System.out.print(charStr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用多个资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> ( InputStream is  = <span class="keyword">new</span> FileInputStream(<span class="string">"/home/biezhi/a.txt"</span>);</div><div class="line">      OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"/home/biezhi/b.txt"</span>)</div><div class="line">) &#123;</div><div class="line">    <span class="keyword">char</span> charStr = (<span class="keyword">char</span>) is.read();</div><div class="line">    os.write(charStr);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然如果你使用的是非标准库的类也可以自定义AutoCloseable，只要实现其close方法即可。</p>
<h3 id="捕获多个Exception"><a href="#捕获多个Exception" class="headerlink" title="捕获多个Exception"></a>捕获多个Exception</h3><p>当我们在操作一个对象的时候，有时候它会抛出多个异常，像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(<span class="number">20000</span>);</div><div class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/a/b.txt"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样代码写起来要捕获很多异常，不是很优雅，JDK7种允许你捕获多个异常:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(<span class="number">20000</span>);</div><div class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/a/b.txt"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException | IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并且<strong>catch</strong>语句后面的异常参数是<strong>final</strong>的，不可以再修改/复制。</p>
<h3 id="处理反射异常"><a href="#处理反射异常" class="headerlink" title="处理反射异常"></a>处理反射异常</h3><p>使用过反射的同学可能知道我们有时候操作反射方法的时候会抛出很多不相关的检查异常，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.biezhi.apple.User"</span>);</div><div class="line">    clazz.getMethods()[<span class="number">0</span>].invoke(object);</div><div class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>尽管你可以使用catch多个异常的方法将上述异常都捕获，但这也让人感到痛苦。<br>JDK7修复了这个缺陷，引入了一个新类ReflectiveOperationException可以帮你捕获这些反射异常:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.biezhi.apple.User"</span>);</div><div class="line">    clazz.getMethods()[<span class="number">0</span>].invoke(object);</div><div class="line">&#125; <span class="keyword">catch</span> (ReflectiveOperationException e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>我们知道在JDK6甚至之前的时候，我们想要读取一个文本文件也是非常麻烦的一件事，而现在他们都变得简单了，<br>这要归功于NIO2，我们先看看之前的做法:</p>
<p><strong>读取一个文本文件</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">BufferedReader br = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"file.txt"</span>));</div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    String line      = br.readLine();</div><div class="line">    <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</div><div class="line">        sb.append(line);</div><div class="line">        sb.append(System.lineSeparator());</div><div class="line">        line = br.readLine();</div><div class="line">    &#125;</div><div class="line">    String everything = sb.toString();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        br.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大家对这样的一段代码一定不陌生，但这样太繁琐了，我只想读取一个文本文件，要写这么多代码还要<br>处理让人头大的一堆异常，怪不得别人吐槽Java臃肿，是在下输了。。。</p>
<p>下面我要介绍在JDK7中是如何改善这些问题的。</p>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>Path用于来表示文件路径和文件，和File对象类似，Path对象并不一定要对应一个实际存在的文件，<br>它只是一个路径的抽象序列。</p>
<p>要创建一个Path对象有多种方法，首先是final类Paths的两个static方法，如何从一个路径字符串来构造Path对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Path path1   = Paths.get(<span class="string">"/home/biezhi"</span>, <span class="string">"a.txt"</span>);</div><div class="line">Path path2   = Paths.get(<span class="string">"/home/biezhi/a.txt"</span>);</div><div class="line">URI  u       = URI.create(<span class="string">"file:////home/biezhi/a.txt"</span>);</div><div class="line">Path pathURI = Paths.get(u);</div></pre></td></tr></table></figure></p>
<p>通过<strong>FileSystems</strong>构造<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Path filePath = FileSystems.getDefault().getPath(<span class="string">"/home/biezhi"</span>, <span class="string">"a.txt"</span>);</div></pre></td></tr></table></figure></p>
<p><strong>Path、URI、File</strong>之间的转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">File file  = new File(&quot;/home/biezhi/a.txt&quot;);</div><div class="line">Path p1    = file.toPath();</div><div class="line">p1.toFile();</div><div class="line">file.toURI();</div></pre></td></tr></table></figure></p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>你可以使用<strong>Files</strong>类快速实现文件操作，例如读取文件内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] data    = Files.readAllBytes(Paths.get(<span class="string">"/home/biezhi/a.txt"</span>));</div><div class="line">String content = <span class="keyword">new</span> String(data, StandardCharsets.UTF_8);</div></pre></td></tr></table></figure></p>
<p>如果希望按照行读取文件，可以调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">"/home/biezhi/a.txt"</span>));</div></pre></td></tr></table></figure></p>
<p>反之你想将字符串写入到文件可以调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Files.write(Paths.get(<span class="string">"/home/biezhi/b.txt"</span>), <span class="string">"Hello JDK7!"</span>.getBytes());</div></pre></td></tr></table></figure></p>
<p>你也可以按照行写入文件，Files.write方法的参数中支持传递一个实现Iterable接口的类实例。<br>将内容追加到指定文件可以使用write方法的第三个参数OpenOption:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Files.write(Paths.get(&quot;/home/biezhi/b.txt&quot;), &quot;Hello JDK7!&quot;.getBytes(),</div><div class="line"> StandardOpenOption.APPEND);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>默认情况Files类中的所有方法都会使用UTF-8编码进行操作，当你不愿意这么干的时候可以传递Charset参数进去变更。<br>当然Files还有一些其他的常用方法:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">InputStream ins  = Files.newInputStream(path);</div><div class="line">OutputStream ops = Files.newOutputStream(path);</div><div class="line">Reader reader    = Files.newBufferedReader(path);</div><div class="line">Writer writer    = Files.newBufferedWriter(path);</div></pre></td></tr></table></figure>
<h3 id="创建、移动、删除"><a href="#创建、移动、删除" class="headerlink" title="创建、移动、删除"></a>创建、移动、删除</h3><p>创建文件、目录<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!Files.exists(path)) &#123;</div><div class="line">    Files.createFile(path);</div><div class="line">    Files.createDirectory(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Files还提供了一些方法让我们创建临时文件/临时目录:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Files.createTempFile(dir, prefix, suffix);</div><div class="line">Files.createTempFile(prefix, suffix);</div><div class="line">Files.createTempDirectory(dir, prefix);</div><div class="line">Files.createTempDirectory(prefix);</div></pre></td></tr></table></figure></p>
<p>这里的dir是一个Path对象，并且字符串prefix和suffix都可能为null。<br>例如调用<strong>Files.createTempFile(null, “.txt”)</strong>会返回一个类似<strong>/tmp/21238719283331124678.txt</strong>的文件</p>
<blockquote>
<p>读取一个目录下的文件请使用Files.list和Files.walk方法</p>
</blockquote>
<p>复制、移动一个文件内容到某个路径<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Files.copy(in, path);</div><div class="line">Files.move(path, path);</div></pre></td></tr></table></figure></p>
<p>删除一个文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Files.delete(path);</div></pre></td></tr></table></figure></p>
<h2 id="小的改进"><a href="#小的改进" class="headerlink" title="小的改进"></a>小的改进</h2><p>Java8是一个较大改变的版本，包含了API和库方面的修正，它还对我们常用的API进行很多微小的调整，下面我会带你了解字符串、集合、注解等新方法。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>使用过JavaScript语言的人可能会知道当我们将一个数组中的元素组合起来变成字符串有一个方法join，<br>例如我们经常用到将数组中的字符串拼接成用逗号分隔的一长串，这在Java中是要写for循环来完成的。</p>
<p>Java8种添加了<strong>join</strong>方法帮你搞定这一切:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str = String.join(<span class="string">","</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div></pre></td></tr></table></figure></p>
<p>第一个参数是分隔符，后面接收一个CharSequence类型的可变参数数组或一个Iterable。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合改变中最大的当属前面章节中提到的Stream API，除此之外还有一些小的改动。</p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/jdk%E6%96%B0%E7%89%B9%E6%80%A71.png" alt=""><br></center>


<ul>
<li>Map中的很多方法对并发访问十分重要，我们将在后面的章节中介绍</li>
<li>Iterator提供forEachRemaining将剩余的元素传递给一个函数</li>
<li>BitSet可以产生一个Stream对象<br><strong>通用目标类型判断</strong></li>
</ul>
<p>Java8对泛型参数的推断进行了增强。相信你对Java8之前版本中的类型推断已经比较熟悉了。<br>比如，Collections中的方法emptyList方法定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">emptyList</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p><strong>emptyList</strong>方法使用了泛型类型<strong>T</strong>进行参数化。你可以像下面这样为该类型参数提供一个显式的类型进行函数调用：</p>
<p>List<person> persons = Collections.<person>emptyList();<br>不过编译器也可以推断泛型参数的类型，上面的代码和下面这段代码是等价的：</person></person></p>
<p>List<person> persons = Collections.emptyList();<br>我还是习惯于这样书写。</person></p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Java 8在两个方面对注解机制进行了改进，分别为：</p>
<ul>
<li>可以定义重复注解</li>
<li>可以为任何类型添加注解</li>
</ul>
<h3 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h3><p>之前版本的Java禁止对同样的注解类型声明多次。由于这个原因，下面的第二句代码是无效的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@interface</span> Basic &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Basic</span>(name=<span class="string">"fix"</span>)</div><div class="line"><span class="meta">@Basic</span>(name=<span class="string">"todo"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; &#125;</div><div class="line">我们之前可能会通过数组的做法绕过这一限制:</div><div class="line"></div><div class="line"><span class="meta">@interface</span> Basic &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@interface</span> Basics &#123;</div><div class="line">    Basic[] value();</div><div class="line">&#125;</div><div class="line"><span class="meta">@Basics</span>( &#123; <span class="meta">@Basic</span>(name=<span class="string">"fix"</span>) , <span class="meta">@Basic</span>(name=<span class="string">"todo"</span>) &#125; )</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; &#125;</div></pre></td></tr></table></figure></p>
<p>Book类的嵌套注解相当难看。这就是Java8想要从根本上移除这一限制的原因，去掉这一限制后，<br>代码的可读性会好很多。现在，如果你的配置允许重复注解，你可以毫无顾虑地一次声明多个同一种类型的注解。<br>它目前还不是默认行为，你需要显式地要求进行重复注解。</p>
<p><strong>创建一个重复注解</strong></p>
<p>如果一个注解在设计之初就是可重复的，你可以直接使用它。但是，如果你提供的注解是为用户提供的，<br>那么就需要做一些工作，说明该注解可以重复。下面是你需要执行的两个步骤：</p>
<ol>
<li>将注解标记为@Repeatable</li>
<li>提供一个注解的容器下面的例子展示了如何将@Basic注解修改为可重复注解<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Repeatable</span>(Basics.class)</div><div class="line"><span class="meta">@interface</span> Basic &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@interface</span> Basics &#123;</div><div class="line">    Basic[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>完成了这样的定义之后，Person类可以通过多个@Basic注解进行注释，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Basic</span>(name=<span class="string">"fix"</span>)</div><div class="line"><span class="meta">@Basic</span>(name=<span class="string">"todo"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; &#125;</div></pre></td></tr></table></figure></p>
<p>编译时， Person 会被认为使用了<strong> @Basics( { @Basic(name=”fix”) , @Basic(name=”todo”)} )</strong><br>这样的形式进行了注解，所以，你可以把这种新的机制看成是一种语法糖，<br>它提供了程序员之前利用的惯用法类似的功能。为了确保与反射方法在行为上的一致性，<br>注解会被封装到一个容器中。 Java API中的getAnnotation(Class<t> annotationClass)方法会为注解元素返回类型为T的注解。<br>如果实际情况有多个类型为T的注解，该方法的返回到底是哪一个呢？</t></p>
<p>我们不希望一下子就陷入细节的魔咒，类Class提供了一个新的getAnnotationsByType方法，<br>它可以帮助我们更好地使用重复注解。比如，你可以像下面这样打印输出Person类的所有Basic注解：</p>
<p>返回一个由重复注解Basic组成的数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Basic[] basics = Person.class.getAnnotationsByType(Basic.class);</div><div class="line">    Arrays.asList(basics).forEach(a -&gt; &#123; </div><div class="line">        System.out.println(a.name()); </div><div class="line">    &#125;); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Null检查"><a href="#Null检查" class="headerlink" title="Null检查"></a>Null检查</h3><p>Objects类添加了两个静态方法isNull和nonNull，在使用流的时候非常有用。</p>
<p>例如获取一个流的所有不为null的对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stream.of(<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="keyword">null</span>, <span class="string">"d"</span>)</div><div class="line">        .filter(Objects::nonNull)</div><div class="line">        .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>空指针异常一直是困扰Java程序员的问题，也是我们必须要考虑的。当业务代码中充满了if else判断null<br>的时候程序变得不再优雅，在Java8中提供了Optional类为我们解决NullPointerException。</p>
<p>我们先来看看这段代码有什么问题?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserName</span><span class="params">(User user)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> user.getName();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码看起来很正常，每个User都会有一个名字。所以调用getUserName方法会发生什么呢？<br>实际这是不健壮的程序代码，当User对象为null的时候会抛出一个空指针异常。</p>
<p>我们普遍的做法是通过判断 user != null 然后获取名称<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserName</span><span class="params">(User user)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">return</span> user.getName();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是如果对象嵌套的层次比较深的时候这样的判断我们需要编写多少次呢？难以想象</p>
<h3 id="处理空指针"><a href="#处理空指针" class="headerlink" title="处理空指针"></a>处理空指针</h3><p>使用Optional优化代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserNameByOptional</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">    Optional&lt;String&gt; userName = Optional.ofNullable(user).map(User::getName);</div><div class="line">    <span class="keyword">return</span> userName.orElse(<span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当user为null的时候我们设置UserName的值为null，否则返回getName的返回值，但此时不会抛出空指针。</p>
<p>在之前的代码片段中是我们最熟悉的命令式编程思维，写下的代码可以描述程序的执行逻辑，得到什么样的结果。<br>后面的这种方式是函数式思维方式，在函数式的思维方式里，结果比过程更重要，不需要关注执行的细节。程序的具体执行由编译器来决定。<br>这种情况下提高程序的性能是一个不容易的事情。</p>
<p>我们再次了解下Optional中的一些使用方法</p>
<h3 id="Optional方法"><a href="#Optional方法" class="headerlink" title="Optional方法"></a>Optional方法</h3><p><strong>创建 Optional 对象</strong></p>
<p>你可以通过静态工厂方法Optional.empty，创建一个空的Optional对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;User&gt; emptyUser = Optional.empty();</div></pre></td></tr></table></figure></p>
<p>创建一个非空值的Optional<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;User&gt; userOptional = Optional.of(user);</div></pre></td></tr></table></figure></p>
<p>如果user是一个null，这段代码会立即抛出一个NullPointerException，而不是等到你试图访问user的属性值时才返回一个错误。</p>
<p>可接受null的Optional<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;User&gt; ofNullOptional = Optional.ofNullable(user);</div></pre></td></tr></table></figure></p>
<p>使用静态工厂方法<strong>Optional.ofNullable</strong>，你可以创建一个允许null值的Optional对象。</p>
<p>如果user是null，那么得到的Optional对象就是个空对象，但不会让你导致空指针。</p>
<p>使用map从Optional对象中提取和转换值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Optional&lt;User&gt; ofNullOptional = Optional.ofNullable(user);</div><div class="line">Optional&lt;String&gt; userName = ofNullOptional.map(User::getName);</div></pre></td></tr></table></figure></p>
<p>这种操作就像我们之前在操作Stream是一样的，获取的只是User中的一个属性。</p>
<p><strong>默认行为及解引用Optional对象</strong></p>
<p>我们决定采用orElse方法读取这个变量的值，使用这种方式你还可以定义一个默认值，<br>遭遇空的Optional变量时，默认值会作为该方法的调用返回值。<br>Optional类提供了多种方法读取 Optional实例中的变量值。</p>
<ul>
<li>get()是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量 值，否则就抛出一个NoSuchElementException异常。所以，除非你非常确定Optional 变量一定包含值，否则使用这个方法是个相当糟糕的主意。此外，这种方式即便相对于 嵌套式的null检查，也并未体现出多大的改进。</li>
<li>orElse(T other)是我们在代码清单10-5中使用的方法，正如之前提到的，它允许你在 Optional对象不包含值时提供一个默认值。</li>
<li>orElseGet(Supplier&lt;? extends T&gt; other)是orElse方法的延迟调用版，Supplier方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时费力的工作， 你应该考虑采用这种方式（借此提升程序的性能），或者你需要非常确定某个方法仅在 Optional为空时才进行调用，也可以考虑该方式（这种情况有严格的限制条件）。</li>
<li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)和get方法非常类似， 它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制希 望抛出的异常类型。</li>
<li>ifPresent(Consumer&lt;? super T&gt;)让你能在变量值存在时执行一个作为参数传入的 方法，否则就不进行任何操作。<br>当前除了这些Optional类也具备一些和Stream类似的API，我们先看看Optional类方法:<center><br><img src="http://ojwkevhas.bkt.clouddn.com/jdk%E6%96%B0%E7%89%B9%E6%80%A72.png" alt=""><br></center>

</li>
</ul>
<p><strong>用Optional封装可能为null的值</strong></p>
<p>目前我们写的大部分Java代码都会使用返回NULL的方式来表示不存在值，比如Map中通过Key获取值，<br>当不存在该值会返回一个null。<br>但是，正如我们之前介绍的，大多数情况下，你可能希望这些方法能返回一个Optional对象。<br>你无法修改这些方法的签名，但是你很容易用Optional对这些方法的返回值进行封装。</p>
<p>我们接着用Map做例子，假设你有一个Map<string, object="">类型的map，访问由key的值时，<br>如果map中没有与key关联的值，该次调用就会返回一个null。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object value = map.get(<span class="string">"key"</span>);</div></pre></td></tr></table></figure></string,></p>
<p>使用Optional封装map的返回值，你可以对这段代码进行优化。要达到这个目的有两种方式：<br>你可以使用笨拙的if-then-else判断语句，毫无疑问这种方式会增加代码的复杂度；<br>或者你可以采用Optional.ofNullable方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Object&gt; value = Optional.ofNullable(map.get(<span class="string">"key"</span>));</div></pre></td></tr></table></figure></p>
<p>每次你希望安全地对潜在为null的对象进行转换，将其替换为Optional对象时，都可以考虑使用这种方法。</p>
<p>参考资料：Java文件IO操作应该抛弃File拥抱Paths和Files</p>
<font color="grey" size="1">注：此博客为博主学习时所收集资料仅供博主自身复习用</font>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/07/%E4%BD%BF%E7%94%A8java8%E5%90%8E%E9%82%A3%E4%BA%9B%E8%A2%AB%E6%9B%BE%E7%BB%8F%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E7%89%B9%E6%80%A7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>java8日期和时间使用技巧</title>
      <link>http://Melodylican.github.io/2017/08/05/java8%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <guid>http://Melodylican.github.io/2017/08/05/java8%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <pubDate>Fri, 04 Aug 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;当你开始使用Java操作日期和时间的时候，会有一些棘手。你也许会通过System.currentTimeMillis()&lt;br&gt;来返回1970年1月1日到今天的毫秒数。或者使用Date类来操作日期；当遇到加减月份、天数的时候&lt;br&gt;你又需要用到Calendar类；当需要格式化日期的时候需要使用java.text.DateFormat类。&lt;br&gt;总而言之在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库，比如: &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//joda-time.sourceforge.net/&quot;&gt;joda-time&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>当你开始使用Java操作日期和时间的时候，会有一些棘手。你也许会通过System.currentTimeMillis()<br>来返回1970年1月1日到今天的毫秒数。或者使用Date类来操作日期；当遇到加减月份、天数的时候<br>你又需要用到Calendar类；当需要格式化日期的时候需要使用java.text.DateFormat类。<br>总而言之在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库，比如: <a href="http://link.zhihu.com/?target=http%3A//joda-time.sourceforge.net/" target="_blank" rel="external">joda-time</a><br><a id="more"></a></p>
<h2 id="现有API存在的问题"><a href="#现有API存在的问题" class="headerlink" title="现有API存在的问题"></a>现有API存在的问题</h2><ul>
<li>线程安全: Date和Calendar不是线程安全的，你需要编写额外的代码处理线程安全问题</li>
<li>API设计和易用性: 由于Date和Calendar的设计不当你无法完成日常的日期操作</li>
<li>ZonedDate和Time: 你必须编写额外的逻辑处理时区和那些旧的逻辑</li>
</ul>
<p>好在<a href="http://link.zhihu.com/?target=http%3A//jcp.org/en/jsr/detail%3Fid%3D310" target="_blank" rel="external">JSR 310</a>规范中为Java8添加了新的API，在java.time包中，新的API纠正了过去的缺陷，</p>
<h2 id="新的日期API"><a href="#新的日期API" class="headerlink" title="新的日期API"></a>新的日期API</h2><ul>
<li>ZoneId: 时区ID，用来确定Instant和LocalDateTime互相转换的规则</li>
<li>Instant: 用来表示时间线上的一个点</li>
<li>LocalDate: 表示没有时区的日期, LocalDate是不可变并且线程安全的</li>
<li>LocalTime: 表示没有时区的时间, LocalTime是不可变并且线程安全的</li>
<li>LocalDateTime: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的</li>
<li>Clock: 用于访问当前时刻、日期、时间，用到时区</li>
<li>Duration: 用秒和纳秒表示时间的数量</li>
</ul>
<p>最常用的就是LocalDate、LocalTime、LocalDateTime了，从它们的名字就可以看出是操作日期<br>和时间的。这些类是主要用于当时区不需要显式地指定的上下文。在本章节中我们将讨论最常用的api。</p>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>LocalDate代表一个IOS格式(yyyy-MM-dd)的日期，可以存储 生日、纪念日等日期。<br>获取当前的日期：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDate localDate = LocalDate.now();</div><div class="line">System.out.println(<span class="string">"localDate: "</span> + localDate);</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">localDate: <span class="number">2017</span>-<span class="number">07</span>-<span class="number">20</span></div></pre></td></tr></table></figure></p>
<p>LocalDate可以指定特定的日期，调用of或parse方法返回该实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDate.of(2017, 07, 20);</div><div class="line">LocalDate.parse(&quot;2017-07-20&quot;);</div></pre></td></tr></table></figure></p>
<p>当然它还有一些其他方法，我们一起来看看：</p>
<p><strong>为今天添加一天，也就是获取明天</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalDate tomorrow = LocalDate.now().plusDays(<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p><strong>从今天减去一个月</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalDate prevMonth = LocalDate.now().minus(<span class="number">1</span>, ChronoUnit.MONTHS);</div></pre></td></tr></table></figure></p>
<p>下面写两个例子，分别解析日期 2017-07-20，获取每周中的星期和每月中的日：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DayOfWeek thursday = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfWeek();</div><div class="line">System.out.println(<span class="string">"周四: "</span> + thursday);</div><div class="line"><span class="keyword">int</span> twenty = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfMonth();</div><div class="line">System.out.println(<span class="string">"twenty: "</span> + twenty);</div></pre></td></tr></table></figure></p>
<p>试试今年是不是闰年:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> leapYear = LocalDate.now().isLeapYear();</div><div class="line">System.out.println(<span class="string">"是否闰年: "</span> + leapYear);</div></pre></td></tr></table></figure></p>
<p>判断是否在日期之前或之后:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> notBefore = LocalDate.parse(<span class="string">"2017-07-20"</span>)</div><div class="line">                .isBefore(LocalDate.parse(<span class="string">"2017-07-22"</span>));</div><div class="line">System.out.println(<span class="string">"notBefore: "</span> + notBefore);</div><div class="line"><span class="keyword">boolean</span> isAfter = LocalDate.parse(<span class="string">"2017-07-20"</span>).isAfter(LocalDate.parse(<span class="string">"2017-07-22"</span>));</div><div class="line">System.out.println(<span class="string">"isAfter: "</span> + isAfter);</div></pre></td></tr></table></figure></p>
<p>获取这个月的第一天:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LocalDate firstDayOfMonth = LocalDate.parse(<span class="string">"2017-07-20"</span>)</div><div class="line">                .with(TemporalAdjusters.firstDayOfMonth());</div><div class="line">System.out.println(<span class="string">"这个月的第一天: "</span> + firstDayOfMonth);</div><div class="line">firstDayOfMonth = firstDayOfMonth.withDayOfMonth(<span class="number">1</span>);</div><div class="line">System.out.println(<span class="string">"这个月的第一天: "</span> + firstDayOfMonth);</div></pre></td></tr></table></figure></p>
<p>判断今天是否是我的生日，例如我的生日是 2017-07-20<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDate birthday = LocalDate.of(<span class="number">2009</span>, <span class="number">07</span>, <span class="number">20</span>);</div><div class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</div><div class="line">MonthDay today = MonthDay.from(LocalDate.now());</div><div class="line">System.out.println(<span class="string">"今天是否是我的生日: "</span> + today.equals(birthdayMd));</div></pre></td></tr></table></figure></p>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>LocalTime表示一个时间，而不是日期，下面介绍一下它的使用方法。</p>
<p>获取现在的时间，输出<strong>15:01:22.144</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalTime now = LocalTime.now();</div><div class="line">System.out.println(<span class="string">"现在的时间: "</span> + now);</div></pre></td></tr></table></figure></p>
<p>将一个字符串时间解析为LocalTime，输出15:02<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalTime nowTime = LocalTime.parse(<span class="string">"15:02"</span>);</div><div class="line">System.out.println(<span class="string">"时间是: "</span> + nowTime);</div></pre></td></tr></table></figure></p>
<p>使用静态方法of创建一个时间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalTime nowTime = LocalTime.of(<span class="number">15</span>, <span class="number">02</span>);</div><div class="line">System.out.println(<span class="string">"时间是: "</span> + nowTime);</div></pre></td></tr></table></figure></p>
<p>使用解析字符串的方式并添加一小时，输出16:02<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalTime nextHour = LocalTime.parse(<span class="string">"15:02"</span>).plus(<span class="number">1</span>, ChronoUnit.HOURS);</div><div class="line">System.out.println(<span class="string">"下一个小时: "</span> + nextHour);</div></pre></td></tr></table></figure></p>
<p>获取时间的小时、分钟<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> hour = LocalTime.parse(<span class="string">"15:02"</span>).getHour();</div><div class="line">System.out.println(<span class="string">"小时: "</span> + hour);</div><div class="line"><span class="keyword">int</span> minute = LocalTime.parse(<span class="string">"15:02"</span>).getMinute();</div><div class="line">System.out.println(<span class="string">"分钟: "</span> + minute);</div></pre></td></tr></table></figure></p>
<p>我们也可以通过之前类似的API检查一个时间是否在另一个时间之前、之后<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> isBefore = LocalTime.parse(<span class="string">"15:02"</span>).isBefore(LocalTime.parse(<span class="string">"16:02"</span>));</div><div class="line"><span class="keyword">boolean</span> isAfter = LocalTime.parse(<span class="string">"15:02"</span>).isAfter(LocalTime.parse(<span class="string">"16:02"</span>));</div><div class="line">System.out.println(<span class="string">"isBefore: "</span> + isBefore);</div><div class="line">System.out.println(<span class="string">"isAfter: "</span> + isAfter);</div></pre></td></tr></table></figure></p>
<p>输出 <strong>isBefore: true, isAfter: false</strong>。</p>
<p>在LocalTime类中也将每天的开始和结束作为常量供我们使用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(LocalTime.MAX);</div><div class="line">System.out.println(LocalTime.MIN);</div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">23:59:59.999999999</div><div class="line">00:00</div></pre></td></tr></table></figure></p>
<p>LocalTime就这些了，下面我们来了解一下LocalDateTime</p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</p>
<p>获取当前的日期和时间:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDateTime now = LocalDateTime.now();</div><div class="line">System.out.println(<span class="string">"现在: "</span> + now);</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">现在: <span class="number">2017</span>-<span class="number">07</span>-<span class="number">20</span>T15:<span class="number">17</span>:<span class="number">19.926</span></div></pre></td></tr></table></figure></p>
<p>下面使用静态方法和字符串的方式分别创建 LocalDateTime 对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDateTime.of(<span class="number">2017</span>, Month.JULY, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>);</div><div class="line">LocalDateTime.parse(<span class="string">"2017-07-20T15:18:00"</span>);</div></pre></td></tr></table></figure></p>
<p>同时<code>LocalDateTime</code>也提供了相关API来对日期和时间进行增减操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDateTime tomorrow = now.plusDays(<span class="number">1</span>);</div><div class="line">System.out.println(<span class="string">"明天的这个时间: "</span> + tomorrow);</div><div class="line">LocalDateTime minusTowHour = now.minusHours(<span class="number">2</span>);</div><div class="line">System.out.println(<span class="string">"两小时前: "</span> + minusTowHour);</div></pre></td></tr></table></figure></p>
<p>这个类也提供一系列的get方法来获取特定单位:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Month month = now.getMonth();</div><div class="line">System.out.println(<span class="string">"当前月份: "</span> + month);</div></pre></td></tr></table></figure></p>
<h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><p>在日常开发中我们用到最多的也许就是日期、时间的格式化了，那在Java8种该如何操作呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">LocalDateTime now = LocalDateTime.now();</div><div class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">System.out.println(<span class="string">"默认格式化: "</span> + now);</div><div class="line">System.out.println(<span class="string">"自定义格式化: "</span> + now.format(dateTimeFormatter));</div><div class="line">LocalDateTime localDateTime = LocalDateTime.parse(<span class="string">"2017-07-20 15:27:44"</span>, dateTimeFormatter);</div><div class="line">System.out.println(<span class="string">"字符串转LocalDateTime: "</span> + localDateTime);</div></pre></td></tr></table></figure></p>
<p>也可以使用<strong>DateTimeFormatter</strong>的<strong>format</strong>方法将日期、时间格式化为字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">String dateString = dateTimeFormatter.format(LocalDate.now());</div><div class="line">System.out.println(<span class="string">"日期转字符串: "</span> + dateString);</div></pre></td></tr></table></figure></p>
<h2 id="日期周期"><a href="#日期周期" class="headerlink" title="日期周期"></a>日期周期</h2><p><strong>Period</strong>类用于修改给定日期或获得的两个日期之间的区别。</p>
<p>给初始化的日期添加5天:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDate initialDate = LocalDate.parse(<span class="string">"2017-07-20"</span>);</div><div class="line">LocalDate finalDate   = initialDate.plus(Period.ofDays(<span class="number">5</span>));</div><div class="line">System.out.println(<span class="string">"初始化日期: "</span> + initialDate);</div><div class="line">System.out.println(<span class="string">"加日期之后: "</span> + finalDate);</div></pre></td></tr></table></figure></p>
<p>周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> between = ChronoUnit.DAYS.between(initialDate, finalDate);</div><div class="line">System.out.println(<span class="string">"差距天数: "</span> + between);</div></pre></td></tr></table></figure></p>
<p>上面的代码会返回5，当然你想获取两个日期相差多少小时也是简单的。</p>
<h2 id="与遗留代码转换"><a href="#与遗留代码转换" class="headerlink" title="与遗留代码转换"></a>与遗留代码转换</h2><p>在之前的代码中你可能出现了大量的Date类，如何将它转换为Java8种的时间类呢？</p>
<p><strong>Date</strong>和<strong>Instant</strong>互相转换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Date date = Date.from(Instant.now());</div><div class="line">Instant instant = date.toInstant();</div></pre></td></tr></table></figure></p>
<p><strong>Date</strong>转换为<strong>LocalDateTime</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDateTime localDateTime = LocalDateTime.from(<span class="keyword">new</span> Date());</div><div class="line">System.out.println(localDateTime);</div></pre></td></tr></table></figure></p>
<p><strong>LocalDateTime</strong>转<strong>Date</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Date date =</div><div class="line">    Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</div></pre></td></tr></table></figure></p>
<p>LocalDate转Date<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Date date =</div><div class="line">    Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant());</div></pre></td></tr></table></figure></p>
<font color="grey" size="1">注：此博客为博主学习时所收集资料仅供博主自身复习用</font>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/05/java8%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>高并发系统数据幂等性</title>
      <link>http://Melodylican.github.io/2017/07/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%B9%82%E7%AD%89%E6%80%A7/</link>
      <guid>http://Melodylican.github.io/2017/07/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%B9%82%E7%AD%89%E6%80%A7/</guid>
      <pubDate>Mon, 24 Jul 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;在系统开发过程中，经常遇到数据重复插入、重复更新、消息重发发送等等问题，因为应用系统的复杂逻辑以及网络交互存在的不确定性，会导致这一重复现象，但是有些逻辑是需要有幂等特性的，否则造成的后果会比较严重，例如订单重复创建，这时候带来的问题可是非同一般啊。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在系统开发过程中，经常遇到数据重复插入、重复更新、消息重发发送等等问题，因为应用系统的复杂逻辑以及网络交互存在的不确定性，会导致这一重复现象，但是有些逻辑是需要有幂等特性的，否则造成的后果会比较严重，例如订单重复创建，这时候带来的问题可是非同一般啊。<br><a id="more"></a></p>
<h2 id="系统的幂等性"><a href="#系统的幂等性" class="headerlink" title="系统的幂等性"></a>系统的幂等性</h2><p> 幂等是数据中得一个概念，表示N次变换和1次变换的结果相同。</p>
<h2 id="高并发的系统如何保证幂等性"><a href="#高并发的系统如何保证幂等性" class="headerlink" title="高并发的系统如何保证幂等性"></a>高并发的系统如何保证幂等性</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p> 查询的API，可以说是天然的幂等性，因为你查询一次和查询两次，对于系统来讲，没有任何数据的变更，所以，查询一次和查询多次一样的；</p>
<h3 id="MVCC方案"><a href="#MVCC方案" class="headerlink" title="MVCC方案"></a>MVCC方案</h3><p> 多版本并发控制，update with condition更新带条件，这也是在系统设计的时候，合理的选择乐观锁，通过version或者其他条件，来做乐观锁，这样保证更新及时在并发的情况下，也不会有太大的问题。<br> 例如update table_xxx set name=#name#,version=version+1 where version=#version# ,或者是 update table_xxx set quality=quality-#subQuality# where quality-#subQuality# &gt;= 0</p>
<h3 id="单独的去重表"><a href="#单独的去重表" class="headerlink" title="单独的去重表"></a>单独的去重表</h3><p> 如果涉及到的去重的地方特别多，例如ERP系统中有各种各样的业务单据，每一种业务单据都需要去重，这时候，可以单独搞一张去重表，在插入数据的时候，插入去重表，利用数据库的唯一索引特性，保证唯一的逻辑；</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p> 还是拿插入数据的例子，如果是分布式系统，构建唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多个系统，也就是分布式系统中得解决思路；</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p> 删除数据，仅仅第一次删除是真正的操作数据，第二次甚至第三次删除，直接返回成功，这样保证了幂等；</p>
<h3 id="插入数据的唯一索引"><a href="#插入数据的唯一索引" class="headerlink" title="插入数据的唯一索引"></a>插入数据的唯一索引</h3><p> 插入数据的唯一性，可以通过业务主键来进行约束，例如一个特定的业务场景，三个字段肯定确定唯一性，那么，可以在数据库表添加唯一索引来进行标示。<br> 这里有一个场景，API层面的幂等，例如提交数据，如何控制重复提交，这里可以在提交数据的form表单或者客户端软件，增加一个唯一标示，然后服务端，根据这个UUID来进行去重，这样就能比较好的做到API层面的唯一标示</p>
<h3 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a>状态机幂等</h3><p> 在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/07/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%B9%82%E7%AD%89%E6%80%A7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何使用MongoDB+SpringBoot实现分布式ID?</title>
      <link>http://Melodylican.github.io/2017/07/13/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8SpringBoot%E5%92%8CMongoDB%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8FID/</link>
      <guid>http://Melodylican.github.io/2017/07/13/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8SpringBoot%E5%92%8CMongoDB%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8FID/</guid>
      <pubDate>Wed, 12 Jul 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;如何实现分布式id，搜索相关的资料，一般会给出这几种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用数据库自增Id&lt;/li&gt;
&lt;li&gt;使用reids的incr命令&lt;/li&gt;
&lt;li&gt;使用UUID&lt;/li&gt;
&lt;li&gt;Twitter的snowflake算法&lt;/li&gt;
&lt;li&gt;利用zookeeper生成唯一ID&lt;/li&gt;
&lt;li&gt;MongoDB的ObjectId&lt;br&gt;另外，在我通过爬取知乎用户id发现，知乎的用户id是32位的，初步断定知乎采用的是md5加密，然后全部转换成小写。至于如何爬取知乎用户信息，见我之前分享的文章。本文采取的技术方案采取的是mogoodb的objectId。&lt;/li&gt;&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如何实现分布式id，搜索相关的资料，一般会给出这几种方案：</p>
<ul>
<li>使用数据库自增Id</li>
<li>使用reids的incr命令</li>
<li>使用UUID</li>
<li>Twitter的snowflake算法</li>
<li>利用zookeeper生成唯一ID</li>
<li>MongoDB的ObjectId<br>另外，在我通过爬取知乎用户id发现，知乎的用户id是32位的，初步断定知乎采用的是md5加密，然后全部转换成小写。至于如何爬取知乎用户信息，见我之前分享的文章。本文采取的技术方案采取的是mogoodb的objectId。<a id="more"></a>
</li>
</ul>
<h2 id="Mongodb如何实现分布式ID"><a href="#Mongodb如何实现分布式ID" class="headerlink" title="Mongodb如何实现分布式ID"></a>Mongodb如何实现分布式ID</h2><p>MongoDB的ObjectId设计成轻量型的，不同的机器都能用全局唯一的同种方法方便地生成它。mongodb 从一开始就设计用来作为分布式数据库，处理多个节点是一个核心要求。使其在分片环境中要容易生成得多。</p>
<p>它的格式： </p>
<center><br><img src="http://upload-images.jianshu.io/upload_images/2279594-fa59770ee4c176cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></center>

<p>前4 个字节是从标准纪元开始的时间戳，单位为秒。时间戳，与随后的5 个字节组合起来，提供了秒级别的唯一性。由于时间戳在前，这意味着ObjectId 大致会按照插入的顺序排列。这对于某些方面很有用，如将其作为索引提高效率。这4 个字节也隐含了文档创建的时间。绝大多数客户端类库都会公开一个方法从ObjectId 获取这个信息。</p>
<p>接下来的3 字节是所在主机的唯一标识符。通常是机器主机名的散列值。这样就可以确保不同主机生成不同的ObjectId，不产生冲突。<br>为了确保在同一台机器上并发的多个进程产生的ObjectId 是唯一的，接下来的两字节来自产生ObjectId 的进程标识符（PID）。</p>
<p>前9 字节保证了同一秒钟不同机器不同进程产生的ObjectId 是唯一的。<br>后3 字节就是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId 也是不一样的。同一秒钟最多允许每个进程拥有2563（16 777 216）个不同的ObjectId。</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>在springboot中引入mongodb:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">     &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">     &lt;scope&gt;test&lt;/scope&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"></div><div class="line"> &lt;!-- 开启web--&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;!--mongodb --&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">     &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>创建一个实体类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="keyword">public</span> String id;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> String firstName;</div><div class="line">    <span class="keyword">public</span> String lastName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(</div><div class="line">                <span class="string">"Customer[id=%s, firstName='%s', lastName='%s']"</span>,</div><div class="line">                id, firstName, lastName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建mongodb 接口类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Customer</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">findByFirstName</span><span class="params">(String firstName)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Customer&gt; <span class="title">findByLastName</span><span class="params">(String lastName)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line">CustomerRepository customerRepository;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mongodbIdTest</span><span class="params">()</span></span>&#123;</div><div class="line">Customer customer=<span class="keyword">new</span> Customer(<span class="string">"lxdxil"</span>,<span class="string">"dd"</span>);</div><div class="line">        customer=customerRepository.save(customer);</div><div class="line">        logger.info( <span class="string">"mongodbId:"</span>+customer.getId());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<font color="grey" size="1">注：此博客参考自 方志朋博客 仅供博主自身复习用</font>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/07/13/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8SpringBoot%E5%92%8CMongoDB%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8FID/#disqus_thread</comments>
    </item>
    
    <item>
      <title>统计网卡流量</title>
      <link>http://Melodylican.github.io/2017/06/06/%E7%BD%91%E5%8D%A1%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/</link>
      <guid>http://Melodylican.github.io/2017/06/06/%E7%BD%91%E5%8D%A1%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/</guid>
      <pubDate>Mon, 05 Jun 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;显示网卡流量的方法蛮多，一般我们可以通过dstat来查看，但dstat不一定所有的机器都有安装。而我们知道，通过ifconfig可以看到某一网卡发送与接收的字节数，所以我们可以写一个脚本来统计一下。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote>
<p>显示网卡流量的方法蛮多，一般我们可以通过dstat来查看，但dstat不一定所有的机器都有安装。而我们知道，通过ifconfig可以看到某一网卡发送与接收的字节数，所以我们可以写一个脚本来统计一下。<br><a id="more"></a></p>
</blockquote>
<p>先看ifconfig:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ ifconfig eth0  </div><div class="line">eth0      Link encap:Ethernet  HWaddr A4:BA:DB:<span class="number">43</span>:BA:B1  </div><div class="line">          inet addr:<span class="number">10.232</span>.4.34  Bcast:<span class="number">10.232</span>.4.255  Mask:<span class="number">255.255</span>.255.0  </div><div class="line">          inet6 addr: fe80::a6ba:dbff:fe43:bab1/<span class="number">64</span> Scope:Link  </div><div class="line">          UP BROADCAST RUNNING MULTICAST  MTU:<span class="number">1500</span>  Metric:<span class="number">1</span>  </div><div class="line">          RX packets:<span class="number">301707081</span> errors:<span class="number">0</span> dropped:<span class="number">1346358</span> overruns:<span class="number">0</span> frame:<span class="number">0</span>  </div><div class="line">          TX packets:<span class="number">296718885</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span>  </div><div class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span>  </div><div class="line">          RX bytes:<span class="number">28485042645</span> (<span class="number">26.5</span> GiB)  TX bytes:<span class="number">35887266717</span> (<span class="number">33.4</span> GiB)  </div><div class="line">          Interrupt:<span class="number">98</span> Memory:d6000000-d6012800</div></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以看到rx与tx两个数据，于是我们的脚本出来了：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">alias ifconfig="/sbin/ifconfig"</div><div class="line">eth=eth0</div><div class="line">while true; do</div><div class="line">RXpre=$(ifconfig $&#123;eth&#125; | grep bytes | awk '&#123;print $2&#125;'| awk -F":" '&#123;print $2&#125;')</div><div class="line">TXpre=$(ifconfig $&#123;eth&#125; | grep bytes | awk '&#123;print $6&#125;' | awk -F":" '&#123;print $2&#125;')</div><div class="line">sleep 1</div><div class="line">RXnext=$(ifconfig $&#123;eth&#125; | grep bytes | awk '&#123;print $2&#125;'| awk -F":" '&#123;print $2&#125;')</div><div class="line">TXnext=$(ifconfig $&#123;eth&#125; | grep bytes | awk '&#123;print $6&#125;' | awk -F":" '&#123;print $2&#125;')</div><div class="line">echo RX ----- TX</div><div class="line">echo "$(((($&#123;RXnext&#125;-$&#123;RXpre&#125;)/1024)/1024))MB/s $(((($&#123;TXnext&#125;-$&#123;TXpre&#125;)/1024/1024)))MB/s"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>脚本暂时比较简单，可以添加一些参数判断，比如多长时间显示一次等等，先看看执行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ ./a  </div><div class="line">RX ----- TX  </div><div class="line"><span class="number">5</span>MB/s <span class="number">7</span>MB/s  </div><div class="line">RX ----- TX  </div><div class="line"><span class="number">5</span>MB/s <span class="number">7</span>MB/s  </div><div class="line">RX ----- TX  </div><div class="line"><span class="number">4</span>MB/s <span class="number">6</span>MB/s  </div><div class="line">RX ----- TX  </div><div class="line"><span class="number">4</span>MB/s <span class="number">6</span>MB/s  </div><div class="line">RX ----- TX</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/06/06/%E7%BD%91%E5%8D%A1%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java线上应用故障排查之一：高CPU占用</title>
      <link>http://Melodylican.github.io/2017/05/26/%E9%AB%98CPU%E5%8D%A0%E7%94%A8/</link>
      <guid>http://Melodylican.github.io/2017/05/26/%E9%AB%98CPU%E5%8D%A0%E7%94%A8/</guid>
      <pubDate>Thu, 25 May 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;问题分析：&lt;br&gt;1，程序属于CPU密集型，和开发沟通过，排除此类情况。&lt;br&gt;2，程序代码有问题，出现死循环，可能性极大。&lt;/p&gt;
&lt;p&gt;问题解决：&lt;br&gt;1，开发那边无法排查代码某个模块有问题，从日志上也无法分析得出。&lt;br&gt;2，记得原来通过strace跟踪的方法解决了一台PHP服务器CPU占用高的问题，但是通过这种方法无效，经过google搜索，发现可以通过下面的方法进行解决，那就尝试下吧。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>问题分析：<br>1，程序属于CPU密集型，和开发沟通过，排除此类情况。<br>2，程序代码有问题，出现死循环，可能性极大。</p>
<p>问题解决：<br>1，开发那边无法排查代码某个模块有问题，从日志上也无法分析得出。<br>2，记得原来通过strace跟踪的方法解决了一台PHP服务器CPU占用高的问题，但是通过这种方法无效，经过google搜索，发现可以通过下面的方法进行解决，那就尝试下吧。<br><a id="more"></a><br>解决过程：<br>1，根据top命令，发现PID为2633的Java进程占用CPU高达300%，出现故障。</p>
<p>2，找到该进程后，如何定位具体线程或代码呢，首先显示线程列表,并按照CPU占用高的线程排序：<br>[root@localhost logs]# ps -mp 2633 -o THREAD,tid,time | sort -rn</p>
<p>显示结果如下：<br>USER     %CPU PRI SCNT WCHAN  USER SYSTEM   TID     TIME<br>root     10.5  19    - -         -      -  3626 00:12:48<br>root     10.1  19    - -         -      -  3593 00:12:16</p>
<p>找到了耗时最高的线程3626，占用CPU时间有12分钟了！</p>
<p>将需要的线程ID转换为16进制格式：<br>[root@localhost logs]# printf “%x\n” 3626<br>e18</p>
<p>最后打印线程的堆栈信息：<br>[root@localhost logs]# jstack 2633 |grep e18 -A 30</p>
<p>将输出的信息发给开发部进行确认，这样就能找出有问题的代码。<br>通过最近几天的监控，CPU已经安静下来了</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/05/26/%E9%AB%98CPU%E5%8D%A0%E7%94%A8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
