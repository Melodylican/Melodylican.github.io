<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>不卑不亢不慌不忙</title>
    <link>http://Melodylican.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>life is struggle</description>
    <pubDate>Mon, 07 May 2018 12:25:28 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Kafka常用命令</title>
      <link>http://Melodylican.github.io/2018/04/20/Kafka%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <guid>http://Melodylican.github.io/2018/04/20/Kafka%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Thu, 19 Apr 2018 16:00:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;kafka-资料整理&quot;&gt;&lt;a href=&quot;#kafka-资料整理&quot; class=&quot;headerlink&quot; title=&quot;kafka 资料整理&quot;&gt;&lt;/a&gt;kafka 资料整理&lt;/h1&gt;&lt;h2 id=&quot;安装-zookeeper-配置-zookeeper-集群&quot;&gt;&lt;a href=&quot;#安装-zookeeper-配置-zookeeper-集群&quot; class=&quot;headerlink&quot; title=&quot;安装 zookeeper 配置 zookeeper 集群&quot;&gt;&lt;/a&gt;安装 zookeeper 配置 zookeeper 集群&lt;/h2&gt;&lt;p&gt;启动 &lt;code&gt;zookeeper: sudo bin/zkServer.sh {start|start-foreground|stop|restart|status|upgrade|print-cmd}&lt;/code&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="kafka-资料整理"><a href="#kafka-资料整理" class="headerlink" title="kafka 资料整理"></a>kafka 资料整理</h1><h2 id="安装-zookeeper-配置-zookeeper-集群"><a href="#安装-zookeeper-配置-zookeeper-集群" class="headerlink" title="安装 zookeeper 配置 zookeeper 集群"></a>安装 zookeeper 配置 zookeeper 集群</h2><p>启动 <code>zookeeper: sudo bin/zkServer.sh {start|start-foreground|stop|restart|status|upgrade|print-cmd}</code></p>
<a id="more"></a>
<h1 id="检测-zookeeper-节点状态"><a href="#检测-zookeeper-节点状态" class="headerlink" title="检测 zookeeper 节点状态"></a>检测 zookeeper 节点状态</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bin/zkServer.sh status</div><div class="line">echo srvr | nc 192.168.0.94 2181</div><div class="line">echo srvr | nc 10.50.75.133 2181</div><div class="line"></div><div class="line"># 连上 zookeeper，并访问目录</div><div class="line">bin/zkCli.sh -server 192.168.0.94:2181</div></pre></td></tr></table></figure>
<h2 id="安装配置-kafka"><a href="#安装配置-kafka" class="headerlink" title="安装配置 kafka"></a>安装配置 kafka</h2><p>编辑 ${KAFKA_HOME}/config/server.properties, 主要参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">host.name=10.50.75.133</div><div class="line">advertised.host.name=10.50.75.133</div><div class="line"></div><div class="line">port=9093</div><div class="line">advertised.port=9093</div><div class="line"></div><div class="line">broker.id=3</div><div class="line"></div><div class="line">listeners=PLAINTEXT://10.50.75.133:9093</div><div class="line"></div><div class="line">advertised.listeners=PLAINTEXT://10.50.75.133:9093</div><div class="line"></div><div class="line">unclean.leader.election.enable=false</div><div class="line">queued.max.requests=16</div><div class="line">num.replica.fetchers=4</div><div class="line">num.network.threads=8</div><div class="line">num.io.threads=12</div><div class="line"></div><div class="line">socket.send.buffer.bytes=1048576</div><div class="line">socket.receive.buffer.bytes=1048576</div><div class="line">socket.request.max.bytes=104857600</div><div class="line"></div><div class="line">log.dirs=/data/kafka-logs2</div><div class="line">num.partitions=8</div><div class="line">log.flush.interval.messages=20000</div><div class="line">log.flush.interval.ms=10000</div><div class="line">log.flush.scheduler.interval.ms=2000</div><div class="line">log.retention.hours=48</div><div class="line">log.retention.bytes=966367641600</div><div class="line">log.segment.bytes=1073741824</div><div class="line">log.retention.check.interval.ms=300000</div><div class="line"></div><div class="line">zookeeper.connect=zs-dw-kafka-dn-1:2181,zs-dw-kafka-dn-2:2181,zs-dw-kafka-dn-3:2181/kafka_1.0</div><div class="line">zookeeper.connection.timeout.ms=10000</div><div class="line"></div><div class="line">group.initial.rebalance.delay.ms=3</div><div class="line"></div><div class="line">default.replication.factor=2</div><div class="line">auto.create.topics.enable=true</div></pre></td></tr></table></figure>
<p>编辑 bin/kafka-server-start.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">export KAFKA_HEAP_OPTS=&quot;-Xmx6g -Xms6g -XX:MetaspaceSize=96m -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:G1HeapRegionSize=16M -XX:MinMetaspaceFreeRatio=50 -XX:MaxMetaspaceFreeRatio=80&quot;</div><div class="line"></div><div class="line">export LOG_DIR=&quot;/data/log/kafka_1.0&quot;</div></pre></td></tr></table></figure>
<p>启动 kafka</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo -E bin/kafka-server-start.sh -daemon config/server.properties</div><div class="line"># -E 命令表示将当前shell环境变量带入执行。 类似 su username 切换新用户保存了当前shell环境变量</div></pre></td></tr></table></figure>
<p>启动完执行 bin/kafka-preferred-replica-election.sh –zookeeper 127.0.0.1:2181 来重新平衡 kafka 各分区的leader</p>
<p>关闭kafka<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ps -ef|grep kafka</div><div class="line">kill -s TERM $PIDS</div></pre></td></tr></table></figure></p>
<h2 id="kafka-命令"><a href="#kafka-命令" class="headerlink" title="kafka 命令"></a>kafka 命令</h2><p>创建topic ‘dlog-test’ ，其中副本数位 2，分区数为 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-topics.sh --zookeeper 127.0.0.1:2181 --create --topic dlog-test --partitions 1 --replication-factor 2</div></pre></td></tr></table></figure></p>
<p>提示：</p>
<pre><code>Topic dlog-test2 is marked for deletion.
Note: This will have no impact if delete.topic.enable is not set to true.
</code></pre><p>删除topic<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-topics.sh --zookeeper 127.0.0.1:2181 --delete --topic dlog-test2</div></pre></td></tr></table></figure></p>
<p>修改 topic 配置，参考 <a href="https://kafka.apache.org/documentation/#topicconfigs" target="_blank" rel="external">3.2 Topic-Level Configs</a></p>
<ol>
<li><p>查看 brokers 配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-configs.sh --describe --zookeeper localhost:2181 --entity-type brokers</div></pre></td></tr></table></figure>
</li>
<li><p>查看 topic 的配置</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics  --describe</div><div class="line"> </div><div class="line">bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name my-topic --describe</div><div class="line"></div><div class="line">bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name PlayerLogin --describe</div></pre></td></tr></table></figure>
<ol>
<li>增加 topic 配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name my-topic --alter --add-config retention.ms=168</div><div class="line"></div><div class="line">bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name PlayerLogin --alter --add-config retention.ms=604800000</div><div class="line"></div><div class="line"># 保留12小时</div><div class="line">bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name CustomEvent --alter --add-config retention.ms=43200000</div></pre></td></tr></table></figure>
<ol>
<li>删除 topic 配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bin/kafka-configs.sh --zookeeper localhost:2181  --entity-type topics --entity-name my-topic --alter --delete-config max.message.bytes</div><div class="line"></div><div class="line">bin/kafka-configs.sh --zookeeper localhost:2181  --entity-type topics --entity-name PlayerLogin --alter --delete-config retention.ms</div></pre></td></tr></table></figure>
<ol>
<li>增加 topic 的 partition 分区数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; bin/kafka-topics.sh --zookeeper zk_host:port/chroot --alter --topic my_topic_name --partitions 40</div><div class="line">bin/kafka-topics.sh --zookeeper 127.0.0.1:2181 --alter --topic CustomEvent --partitions 4</div></pre></td></tr></table></figure>
<p>查看topic</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bin/kafka-topics.sh --zookeeper 127.0.0.1:2181 --list</div><div class="line">bin/kafka-topics.sh --zookeeper 127.0.0.1:2181 --describe</div><div class="line">bin/kafka-topics.sh --zookeeper 127.0.0.1:2181 --describe --topic PlayerLogin</div><div class="line">bin/kafka-topics.sh --zookeeper 127.0.0.1:2181 --describe --topic CustomEvent</div></pre></td></tr></table></figure>
<p>手动触发分区重新选举，类似  auto.leader.rebalance.enable=true 参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-preferred-replica-election.sh --zookeeper 127.0.0.1:2181</div></pre></td></tr></table></figure></p>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Created preferred replica election path with &#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;MutableFlow&quot;,&quot;partition&quot;:2&#125;,&#123;&quot;topic&quot;:&quot;TC_MailFlow&quot;,&quot;partition&quot;:0&#125;,&#123;&quot;topic&quot;:&quot;RoundFlow&quot;,&quot;partition&quot;:2&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerExpFlow&quot;,&quot;partition&quot;:0&#125;,&#123;&quot;topic&quot;:&quot;SnsFlow&quot;,&quot;partition&quot;:1&#125;,&#123;&quot;topic&quot;:&quot;TC_404Item&quot;,&quot;partition&quot;:0&#125;,...]&#125;</div><div class="line">Successfully started preferred replica election for partitions Set([TC_MailFlow,1], [__consumer_offsets,32], [LBS_DATA,2], [__consumer_offsets,16], [__consumer_offsets,49], [__consumer_offsets,44],...)</div></pre></td></tr></table></figure></p>
<p>查看当前 topic 最大 offsets<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 --time -1 --topic topiname</div></pre></td></tr></table></figure></p>
<p>最小offset<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 --time -2 --topic topiname</div></pre></td></tr></table></figure></p>
<p>简单消费<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bin/kafka-simple-consumer-shell.sh --broker-list &quot;172.16.150.132:9093&quot; --topic PlayerLogin</div><div class="line"></div><div class="line">bin/kafka-simple-consumer-shell.sh -broker-list &quot;192.168.0.94:9092,192.168.0.93:9092&quot; --offset -1  --topic CustomEvent</div><div class="line"></div><div class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic PlayerLogin --from-beginning</div></pre></td></tr></table></figure></p>
<p>查看消费详情<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 旧版kafka 消费组的 offset 保存在 zookeeper</div><div class="line">bin/kafka-consumer-groups.sh --zookeeper localhost:2181 --list</div><div class="line"># 新版kafka 消费组的 offset 保存在 kafka</div><div class="line">bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server localhost:9092 --list</div><div class="line"></div><div class="line">bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server localhost:9092 --describe --group dlog_rtc_group_PlayerLogin</div><div class="line"></div><div class="line"> bin/kafka-consumer-groups.sh --bootstrap-server 172.16.150.130:9093 --describe --group dlog_rtc_group_CustomEvent</div></pre></td></tr></table></figure></p>
<p>kafka 平衡leader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bin/kafka-preferred-replica-election.sh --zookeeper 127.0.0.1:2181</div><div class="line">或</div><div class="line">auto.leader.rebalance.enable=true</div></pre></td></tr></table></figure></p>
<p>迁移数据，达到集群数据平衡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --topics-to-move-json-file topics-to-move.json --broker-list &quot;3,4&quot; --generate</div><div class="line"></div><div class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json --execute</div><div class="line"></div><div class="line"># topic 分区重新分配，同时限速 50000000 B/s</div><div class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2185 --reassignment-json-file expand-cluster-reassignment.json --execute --throttle 50000000</div><div class="line"></div><div class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json --verify</div><div class="line"></div><div class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json --verify |grep &quot;still in progress&quot;</div><div class="line"></div><div class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file custom-reassignment.json --execute</div><div class="line"></div><div class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json --execute</div></pre></td></tr></table></figure></p>
<p>对于数据量非常大的topic，可以临时将topic数据保存时间设置成很小，然后执行迁移任务，等迁移完再调回原来时间</p>
<p>中断迁移任务</p>
<p>一旦启动reassign 脚本，则无法停止迁移任务。如果需要强制停止，可以通过zookeeper 进行修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ zookeeper-client -server 10.1.1.50:2181/kafka</div><div class="line">[zk] delete /admin/reassign_partitions</div></pre></td></tr></table></figure>
<p>链接：<a href="https://www.jianshu.com/p/626b147821cd" target="_blank" rel="external">https://www.jianshu.com/p/626b147821cd</a></p>
<p>添加副本数也是一样道理</p>
<p>cat topics-to-move.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;topics&quot;: [</div><div class="line">  &#123;&quot;topic&quot;: &quot;TC_404Item&quot;&#125;,</div><div class="line">  &#123;&quot;topic&quot;: &quot;TC_CityWarFlow&quot;&#125;,</div><div class="line">  &#123;&quot;topic&quot;: &quot;TC_DepositFlow&quot;&#125;,</div><div class="line">  &#123;&quot;topic&quot;: &quot;TC_EquipFlow&quot;&#125;,</div><div class="line">  &#123;&quot;topic&quot;: &quot;TC_GuildFlow&quot;&#125;,</div><div class="line">  &#123;&quot;topic&quot;: &quot;TC_ItemFlow&quot;&#125;,</div><div class="line">  &#123;&quot;topic&quot;: &quot;TC_MailFlow&quot;&#125;,</div><div class="line">  &#123;&quot;topic&quot;: &quot;TC_MoneyFlow&quot;&#125;,</div><div class="line">  &#123;&quot;topic&quot;: &quot;TC_PlayerExpFlow&quot;&#125;,</div><div class="line">  &#123;&quot;topic&quot;: &quot;TC_PlayerRegister&quot;&#125;</div><div class="line">  ],</div><div class="line">&quot;version&quot;:1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>bin/kafka-reassign-partitions.sh –zookeeper localhost:2181 –topics-to-move-json-file topics-to-move.json –broker-list “1,2,3” –generate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;TC_GuildFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[3]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerExpFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1]&#125;,&#123;&quot;topic&quot;:&quot;TC_EquipFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[3]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerRegister&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[3]&#125;,&#123;&quot;topic&quot;:&quot;TC_MailFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[3]&#125;,&#123;&quot;topic&quot;:&quot;TC_ItemFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerRegister&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[2]&#125;,&#123;&quot;topic&quot;:&quot;TC_GuildFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1]&#125;,&#123;&quot;topic&quot;:&quot;TC_MoneyFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[1]&#125;,&#123;&quot;topic&quot;:&quot;TC_EquipFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerRegister&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[1]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerExpFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2]&#125;,&#123;&quot;topic&quot;:&quot;TC_ItemFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[3]&#125;,&#123;&quot;topic&quot;:&quot;TC_DepositFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[1]&#125;,&#123;&quot;topic&quot;:&quot;TC_MoneyFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[2]&#125;,&#123;&quot;topic&quot;:&quot;TC_MailFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1]&#125;,&#123;&quot;topic&quot;:&quot;TC_GuildFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2]&#125;,&#123;&quot;topic&quot;:&quot;TC_DepositFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[2]&#125;,&#123;&quot;topic&quot;:&quot;TC_MoneyFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[3]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerExpFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[3]&#125;,&#123;&quot;topic&quot;:&quot;TC_EquipFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2]&#125;,&#123;&quot;topic&quot;:&quot;TC_404Item&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[3]&#125;,&#123;&quot;topic&quot;:&quot;TC_DepositFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[3]&#125;,&#123;&quot;topic&quot;:&quot;TC_MailFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2]&#125;,&#123;&quot;topic&quot;:&quot;TC_ItemFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1]&#125;,&#123;&quot;topic&quot;:&quot;TC_404Item&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1]&#125;,&#123;&quot;topic&quot;:&quot;TC_404Item&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2]&#125;]&#125;</div></pre></td></tr></table></figure>
<p>配置文件改成 expand-cluster-reassignment.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;TC_GuildFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[3,1]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerExpFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,2]&#125;,&#123;&quot;topic&quot;:&quot;TC_EquipFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[3,1]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerRegister&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[3,1]&#125;,&#123;&quot;topic&quot;:&quot;TC_MailFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[3,1]&#125;,&#123;&quot;topic&quot;:&quot;TC_ItemFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2,3]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerRegister&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[2,3]&#125;,&#123;&quot;topic&quot;:&quot;TC_GuildFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,2]&#125;,&#123;&quot;topic&quot;:&quot;TC_MoneyFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[1,2]&#125;,&#123;&quot;topic&quot;:&quot;TC_EquipFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,2]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerRegister&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[1,2]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerExpFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2,3]&#125;,&#123;&quot;topic&quot;:&quot;TC_ItemFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[3,1]&#125;,&#123;&quot;topic&quot;:&quot;TC_DepositFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[1,2]&#125;,&#123;&quot;topic&quot;:&quot;TC_MoneyFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[2,3]&#125;,&#123;&quot;topic&quot;:&quot;TC_MailFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,2]&#125;,&#123;&quot;topic&quot;:&quot;TC_GuildFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2,3]&#125;,&#123;&quot;topic&quot;:&quot;TC_DepositFlow&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[2,3]&#125;,&#123;&quot;topic&quot;:&quot;TC_MoneyFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[3,1]&#125;,&#123;&quot;topic&quot;:&quot;TC_PlayerExpFlow&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[3,1]&#125;,&#123;&quot;topic&quot;:&quot;TC_EquipFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2,3]&#125;,&#123;&quot;topic&quot;:&quot;TC_404Item&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[3,1]&#125;,&#123;&quot;topic&quot;:&quot;TC_DepositFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[3,1]&#125;,&#123;&quot;topic&quot;:&quot;TC_MailFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2,3]&#125;,&#123;&quot;topic&quot;:&quot;TC_ItemFlow&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,2]&#125;,&#123;&quot;topic&quot;:&quot;TC_404Item&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,2]&#125;,&#123;&quot;topic&quot;:&quot;TC_404Item&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2,3]&#125;]&#125;</div></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json --execute</div></pre></td></tr></table></figure></p>
<p>验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json --verify</div></pre></td></tr></table></figure></p>
<h1 id="kafka-生产消费速率控制，-限速"><a href="#kafka-生产消费速率控制，-限速" class="headerlink" title="kafka 生产消费速率控制， 限速"></a>kafka 生产消费速率控制， 限速</h1><p>添加修改配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-configs.sh  --zookeeper localhost:2181 --alter --add-config &apos;producer_byte_rate=102400,consumer_byte_rate=2097152&apos; --entity-type clients --entity-name client-test</div></pre></td></tr></table></figure></p>
<p>查看配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-configs.sh  --zookeeper localhost:2181 --describe --entity-type clients</div></pre></td></tr></table></figure></p>
<p>删除配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-configs.sh  --zookeeper localhost:2181 --alter --delete-config producer_byte_rate,consumer_byte_rate --entity-type clients --entity-name client-test</div></pre></td></tr></table></figure></p>
<p>直接通过 zookeeper 删除配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bin/zkCli.sh -server 127.0.0.1:2181</div><div class="line">ls /config/clients</div><div class="line">get /config/clients/client-test</div><div class="line">delete /config/clients/client-test</div></pre></td></tr></table></figure></p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2018/04/20/Kafka%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>缓存踩过的坑</title>
      <link>http://Melodylican.github.io/2017/12/07/%E7%BC%93%E5%AD%98%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</link>
      <guid>http://Melodylican.github.io/2017/12/07/%E7%BC%93%E5%AD%98%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</guid>
      <pubDate>Wed, 06 Dec 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;今天讲的这个话题，我相信是众多工程师和团队的痛。从我刚开始工作，那时候构建本地缓存，到后续memcache, Redis的出现，到现在各种分布式集群的缓存，例如redis Cluster等产品的出现，缓存越来越发达和复杂了，缓存对我们的系统也越发重要，现在很难相信一个后端服务里没有缓存的存在。在这篇文章里，我会和大家分享一下过去踩到的缓存坑，然后试图给出一些解决方案，大家可以一起讨论，最终拿出更好的方法。由于篇幅有限，所以这里的缓存讨论，只局限于后端服务的缓存，并且不涉及具体的框架，对于H5,iOS和Android等前端缓存的讨论本文暂时不会涉及。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今天讲的这个话题，我相信是众多工程师和团队的痛。从我刚开始工作，那时候构建本地缓存，到后续memcache, Redis的出现，到现在各种分布式集群的缓存，例如redis Cluster等产品的出现，缓存越来越发达和复杂了，缓存对我们的系统也越发重要，现在很难相信一个后端服务里没有缓存的存在。在这篇文章里，我会和大家分享一下过去踩到的缓存坑，然后试图给出一些解决方案，大家可以一起讨论，最终拿出更好的方法。由于篇幅有限，所以这里的缓存讨论，只局限于后端服务的缓存，并且不涉及具体的框架，对于H5,iOS和Android等前端缓存的讨论本文暂时不会涉及。<br><a id="more"></a><br><strong>案例1，缓存和DB的同步更新不在同一个事务里并且没有重试补偿机制</strong></p>
<p>为了减少系统间的依赖，不同系统的数据更新往往不放在同一个事务里，采用MQ来进行通信。大家可以看下图，后台系统CRM更新产品数据到DB，Product系统收到异步消息通知后，更新最新数据到缓存。这是一个最常见的缓存应用场景，我相信很多团队都是这样用的。在这个Case里容易出现的问题在于，如果批处理任务收到消息后服务crash掉了，缓存没有正常更新，就出现了与DB的数据不同步，前端系统一直不能读到最新数据，导致业务异常。</p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/%E7%BC%93%E5%AD%98%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%911.png" alt=""><br></center>

<p><strong>解决方案：</strong></p>
<ol>
<li><p>失败消息一定要建立一定时间间隔的重试机制</p>
</li>
<li><p>系统要有缓存更新的报警机制，方便更新失败或者重试超时后，可以人工介入进行补偿。</p>
</li>
</ol>
<p><strong>案例2， 同一数据被1个以上的服务执行写操作，其中一个服务的缓存数据没有版本控制</strong></p>
<p>这也是两个不同服务更新数据过程中很常见的情况，见下图，CRM系统更新了某个用户的Profile, 保存更新数据库后，通过MQ通知用户系统更新缓存，由于是异步更新延迟，在缓存更新前，用户系统收到前端的指令，读取了当前缓存里的用户数据，做了修改，并更新到DB中。出现的结果就是数据库里的CRM的更新被错误覆盖。</p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/%E7%BC%93%E5%AD%98%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%912.png" alt=""><br></center>

<p><strong>解决方案</strong>：缓存里的数据有一个标志位可以作为更新数据库数据的依据（Update_time or Version）, 如果缓存里数据时间与数据库时间不能匹配，意味着另外一个服务更新了该数据，那么就先从DB里读取最新数据版本，然后在新版本上提交数据。</p>
<p><strong>案例3， 并发查询缓存中同一数据，如果缓存没命中，导致DB瞬时被打爆</strong></p>
<p>做促销活动的时候，存在大量用户的并发访问某一个特定商品，该商品数据缓存失效，或者做了数据更改，但是对应缓存还没有更新，那么所有这些访问将同时直接被作用到DB上。</p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/%E7%BC%93%E5%AD%98%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%913.png" alt=""><br></center>

<p><strong>解决方案</strong>：做一个计数器或者锁（没有特别复杂逻辑的话，可以直接用HashMap），如果发现某个KEY缓存没有命中，那么在计数器+1, 然后访问数据库，拿到结果更新缓存，清理掉计数器中的key。 在这个过程中，如果有第二个线程或者更多的线程需要访问这个KEY时，发现计数器的值&gt;1 或者被加锁, 那么wait, 直到计数器清理掉，当然，这个技术器阈值是可以在配置文件里配置的，不一定是1。</p>
<p><strong>案例4， 缓存没有设置默认值，被攻击，缓存一直保持在被“穿透”状态</strong></p>
<p>这个情况，和案例3比较类似，都是缓存无法命中，但不一样的地方在于，数据的KEY值是无法控制的，所以没法简单的用计数器和锁来处理, 比方，被人为攻击，制造的大量的无效userID访问。</p>
<p><strong>解决方案</strong>：所有没有在缓存的KEY，全部分配一个默认VALUE “UNKOWN-KEY” ，具体是什么情况下，将默认值分配给没有命中的KEY， 这个可以根据自己的业务系统来定，比方说，可以根据特定的IP段，或者没有命中的总次数等，然后我们就可以决定是否继续访问DB还是直接返回默认值给前端，拒绝本次数据访问。这种做法的核心在于，每次数据访问，都会有缓存结果返回，根据系统的情况来决定是否要进一步访问DB。</p>
<p>总结，今天列举的这几个案例，归纳起来，可以总结为以下几点：</p>
<ol>
<li><p>保证缓存同步</p>
</li>
<li><p>减少缓存并发</p>
</li>
<li><p>杜绝缓存穿透</p>
</li>
</ol>
<p>缓存与背后的DB是相互依存的关系，缓存系统的设计原则，就是将访问的异常处理或者压力尽可能的前置处理掉，将DB还原成它最初本来的存储功能。</p>
<font size="1"><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUwMjM4MA%3D%3D&mid=2247483718&idx=1&sn=3324abf6b2a3245e330b35213ee922a5&chksm=eb478a05dc300313355f4e437ec701b58356c4aa19ad36c46c4031216dab3016e016bda8afee" target="_blank" rel="external">原文地址</a> </font>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/12/07/%E7%BC%93%E5%AD%98%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ansible when register使用</title>
      <link>http://Melodylican.github.io/2017/11/23/Ansible-when-register%E4%BD%BF%E7%94%A8/</link>
      <guid>http://Melodylican.github.io/2017/11/23/Ansible-when-register%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Wed, 22 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;当一条命令执行不成功，执行另外的命令，可以使用when 与register ,使用如下&lt;br&gt;任务配置文件test.yml：&lt;br&gt;&lt;img src=&quot;http://ojwkevhas.bkt.clouddn.com/ansible1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>当一条命令执行不成功，执行另外的命令，可以使用when 与register ,使用如下<br>任务配置文件test.yml：<br><img src="http://ojwkevhas.bkt.clouddn.com/ansible1.png" alt=""></p>
<a id="more"></a>
<p>执行演示：<br><img src="http://ojwkevhas.bkt.clouddn.com/ansible2.png" alt=""></p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/23/Ansible-when-register%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>“秒杀”问题的数据库和SQL设计</title>
      <link>http://Melodylican.github.io/2017/11/23/%E7%A7%92%E6%9D%80%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AE%BE%E8%AE%A1/</link>
      <guid>http://Melodylican.github.io/2017/11/23/%E7%A7%92%E6%9D%80%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AE%BE%E8%AE%A1/</guid>
      <pubDate>Wed, 22 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;问题的来源&quot;&gt;&lt;a href=&quot;#问题的来源&quot; class=&quot;headerlink&quot; title=&quot;问题的来源&quot;&gt;&lt;/a&gt;问题的来源&lt;/h2&gt;&lt;p&gt;最近发现很多人被类似秒杀这样的设计困扰，其实这类问题可以很方便地解决，先来说说这类问题的关键点是什么：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一定要高性能，不然还能叫秒杀吗？&lt;/li&gt;
&lt;li&gt;要强一致性，库存只有100个，不能卖出去101个吧？但是库存10000实际只卖了9999是否允许呢？&lt;/li&gt;
&lt;li&gt;既然这里说了是秒杀，那往往还会针对每个用户有购买数量的限制。&lt;br&gt;总结一下，还是那几个词：高性能强一致性！&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;下文的所有解决方案是在 Mysql InnoDB 下做的。因为用到了很多数据库特性。其他的数据库或其他的数据库引擎会有不同的表现，请注意。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="问题的来源"><a href="#问题的来源" class="headerlink" title="问题的来源"></a>问题的来源</h2><p>最近发现很多人被类似秒杀这样的设计困扰，其实这类问题可以很方便地解决，先来说说这类问题的关键点是什么：</p>
<ol>
<li>一定要高性能，不然还能叫秒杀吗？</li>
<li>要强一致性，库存只有100个，不能卖出去101个吧？但是库存10000实际只卖了9999是否允许呢？</li>
<li>既然这里说了是秒杀，那往往还会针对每个用户有购买数量的限制。<br>总结一下，还是那几个词：高性能强一致性！</li>
</ol>
<blockquote>
<p>下文的所有解决方案是在 Mysql InnoDB 下做的。因为用到了很多数据库特性。其他的数据库或其他的数据库引擎会有不同的表现，请注意。<br><a id="more"></a></p>
</blockquote>
<h2 id="完全不考虑一致性的方案"><a href="#完全不考虑一致性的方案" class="headerlink" title="完全不考虑一致性的方案"></a>完全不考虑一致性的方案</h2><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+-----------+------------------+------+-----+---------+----------------+</div><div class="line">| Field     | Type             | Null | Key | Default | Extra          |</div><div class="line">+-----------+------------------+------+-----+---------+----------------+</div><div class="line">| id        | int(11) unsigned | NO   | PRI | NULL    | auto_increment |</div><div class="line">| user_id   | int(11)          | NO   |     | NULL    |                |</div><div class="line">| deal_id   | int(11)          | NO   |     | NULL    |                |</div><div class="line">| buy_count | int(11)          | NO   |     | NULL    |                |</div><div class="line">+-----------+------------------+------+-----+---------+----------------+</div></pre></td></tr></table></figure>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>表结构很简单，其实就是一个user和deal的关联表。谁买了多少就插入数据呗。</p>
<p>首先，还要检查一下传过来的buy_count是否超过单人购买限制。</p>
<p>接下来，每次插入前执行以下操作检查一下是否超卖即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sum(buy_count) from UserDeal where deal_id = ?</div></pre></td></tr></table></figure></p>
<p>最后还要检查一下这个用户是否购买过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select count(*) from UserDeal where user_id = ? and deal_id = ?</div></pre></td></tr></table></figure></p>
<p>全都没问题了就插入数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">insert into UserDeal (user_id, deal_id, buy_count) values (?, ?, ?)</div></pre></td></tr></table></figure></p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>大家别笑，这样的设计你一定做过，刚毕业的时候谁没设计过这样的系统啊？而且大部分系统对性能和一致性的要求并没有那么高，所以以上的设计方案还真是普遍存在的。</p>
<p>那就说说在什么情况下会出问题吧：</p>
<ol>
<li>如果库存只剩一个，两个用户同时点购买，两个人检查全部成功，最后，就超卖了。</li>
<li>如果一个用户同时发起两次请求，检测部分同样可能会同时通过，最后，数据就异常了。<br>那就让我们一步步来解决里面存在的问题吧。</li>
</ol>
<h3 id="保证单用户不会重复购买"><a href="#保证单用户不会重复购买" class="headerlink" title="保证单用户不会重复购买"></a>保证单用户不会重复购买</h3><p>先来解决最简单的问题，保证单用户不会重复购买。</p>
<p>其实只要利用数据库特性即可，让我们来加一个索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table UserDeal add unique user_id_deal_id(user_id, deal_id)</div></pre></td></tr></table></figure></p>
<p>加上唯一索引后，不仅查询性能提高了，插入的时候如果重复还会自动报错。</p>
<p>当然别忘了在业务代码中 catch 一下这个异常，并在页面上给用户友好的提醒。</p>
<h3 id="解决超卖问题"><a href="#解决超卖问题" class="headerlink" title="解决超卖问题"></a>解决超卖问题</h3><h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h4><p>为了解决这个问题，第一个想到的就是把这几次操作在事务中操作。否则无论怎么改，也都不是原子性的了。</p>
<p>但是加完事务后就完了？</p>
<p>上面的<strong>select</strong>语句没有使用<strong>for update</strong>关键字，所以就算加入了事务也不会影响其他人读写。</p>
<p>所以我们只要改一下select语句即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sum(buy_count) from UserDeal where deal_id = ? for update</div></pre></td></tr></table></figure></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>刚改完后发现，问题解决了！so easy！步步高点读机，哪里不会点哪里，so easy！</p>
<p>但是不对啊！为什么两个用户操作不同的deal也会相互影响呢？</p>
<p>原来我们的select语句中的查询条件是<strong>where deal_id = ?</strong>，你以为只会锁所有满足条件的数据对吧？</p>
<p>但实际上，如果你查询的条件不在索引中，那么 <strong>InnoDB</strong> 会启用表锁！</p>
<p>那就加一个索引呗：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table UserDeal add index ix_deal_id(deal_id)</div></pre></td></tr></table></figure></p>
<h3 id="提高性能了"><a href="#提高性能了" class="headerlink" title="提高性能了"></a>提高性能了</h3><p>好了，到目前为止，无论用户怎没点，无论多少个人买同一单，都不会出现一致性的问题的。</p>
<p>而且事务都是行锁，如果你的业务场景不是秒杀，操作是分散在各个单子上的。而且你的压力不大，那么优化到这就够了。</p>
<p>但是，如果你真的会有几万人、几十万人同时秒杀一个单子怎么办？</p>
<p>很多交易类网站都会有这样的活动。</p>
<p>我们现在思考一下，上面的优化好像已经是极致了，不仅满足了一致性，而且性能方面也做了足够的考量，无从下手啊！</p>
<p>这时候，只能牺牲一些东西了。</p>
<h3 id="鱼与熊掌不可兼得"><a href="#鱼与熊掌不可兼得" class="headerlink" title="鱼与熊掌不可兼得"></a>鱼与熊掌不可兼得</h3><h4 id="优化的思路"><a href="#优化的思路" class="headerlink" title="优化的思路"></a>优化的思路</h4><p>性能和一致性常常同时出现，却又相互排斥。刚才我们为了解决一致性问题带入了性能问题。现在我们又要为了性能而牺牲一致性了。</p>
<p>这里想提高性能的话，就要去掉事务了。那么一旦去掉事务，一致性就没办法保证了，但有些一致性的问题并不是那么地严重。</p>
<p>所以，这里最关键的就是要想清楚，你的业务场景对什么不能容忍，对什么可以容忍。不同业务场景最后的方案一定是不同的。</p>
<h4 id="秒杀可以容忍什么"><a href="#秒杀可以容忍什么" class="headerlink" title="秒杀可以容忍什么"></a>秒杀可以容忍什么</h4><p>本文标题说的是秒杀，因为这个业务场景很常见，那么我们就来说说秒杀。</p>
<p>秒杀最怕的是超卖，但却可以接受少卖。什么是少卖？我有一万份，卖了9999份，但数据库里却说已经买完了。</p>
<p>这个严重吗？只要我们能把这个错误的量控制在一定比例以内并且可以后续修复，那这在秒杀中就不是一个问题了。</p>
<h3 id="为了性能牺牲一致性的设计方案"><a href="#为了性能牺牲一致性的设计方案" class="headerlink" title="为了性能牺牲一致性的设计方案"></a>为了性能牺牲一致性的设计方案</h3><h4 id="去掉了事务会发生什么"><a href="#去掉了事务会发生什么" class="headerlink" title="去掉了事务会发生什么"></a>去掉了事务会发生什么</h4><p>在上述的方案中，如果去掉了事务，单用户重复购买是不会有问题的，因为这个是通过唯一索引来实现的。</p>
<p>所以这边我们主要是去解决超卖问题。</p>
<p>既然去掉了事务，那么<strong>for update</strong>锁行就无效了，我们可以另辟蹊径，来解决这个问题。</p>
<h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><p>刚才一直没有提Deal表，其实它就是存了一下基本信息，包括最大售卖量。</p>
<p>之前我们是通过对关联表进行<strong>sum(buy_count)</strong>操作来得到已经卖掉的数量的，然后进行判断后再进行插入数据。</p>
<p>现在没了事务，这样的操作就不是原子性的了。</p>
<p>所以让我们来修改一下Deal表，把已经售卖的量也存放在Deal表中，然后巧妙地把操作转换成一行update语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+-----------+------------------+------+-----+---------+----------------+</div><div class="line">| Field     | Type             | Null | Key | Default | Extra          |</div><div class="line">+-----------+------------------+------+-----+---------+----------------+</div><div class="line">| id        | int(11) unsigned | NO   | PRI | NULL    | auto_increment |</div><div class="line">| buy_max   | int(11)          | NO   |     | NULL    |                |</div><div class="line">| buy_count | int(11)          | NO   |     | NULL    |                |</div><div class="line">+-----------+------------------+------+-----+---------+----------------+</div></pre></td></tr></table></figure></p>
<h4 id="修改执行过程"><a href="#修改执行过程" class="headerlink" title="修改执行过程"></a>修改执行过程</h4><p>如果你继续先把数据查出来到内存中然后再操作，那就不是原子性的了，必定会出问题。</p>
<p>这时候，神奇的update语句来了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update Deal set buy_count = buy_count + 1 where id = ? and buy_count + 1 &lt;= buy_max</div></pre></td></tr></table></figure></p>
<p>如果一单的buy_max是1000，如果有2000个用户同时操作会发生什么？</p>
<p>虽然没有事务，但是update语句天然会有行锁，前1000个用户都会执行成功，返回生效行数1。而剩下的1000人不会报错，但是生效行数为0。</p>
<p>所以程序中只要判断update语句的生效行数就知道是否抢购成功了。</p>
<h4 id="还没有结束"><a href="#还没有结束" class="headerlink" title="还没有结束"></a>还没有结束</h4><p>问题解决了？好像也没牺牲一致性啊，用户根本不会超卖啊？</p>
<p>但是，购买的时候有两个关键信息，“剩余多少”和“谁买了”，刚才的执行过程只处理了第一个信息，它根本没存“谁买了”这个信息。</p>
<p>而这两个信息其实也是原子性的，但是为了性能，我们不得不牺牲一下了。</p>
<p>刚才说到如果update的生效行数是1，就代表购买成功。所以，如果一个用户购买成功了，那么就再去UserDeal表中插入一下数据。</p>
<p>可如果一个用户重复购买了，那么这里也会出错，所以如果这里出错的话还需要去操作一下Deal表把刚才购买的还回去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update Deal set buy_count = buy_count - 1 where id = ? and buy_count - 1 &gt;= 0</div></pre></td></tr></table></figure></p>
<p>这边理论上不会出现buy_count - 1 &lt; 0的情况，除非你实现的不对。</p>
<p>…… 无图无真相，完全混乱了</p>
<p>只看文字不清晰，还是来张完整的流程图吧！</p>
<p><img src="http://ojwkevhas.bkt.clouddn.com/%E7%A7%92%E6%9D%80%E6%95%B0%E6%8D%AE%E5%BA%93sql%E8%AE%BE%E8%AE%A11.png" alt=""></p>
<p>毫无破绽啊！不是说要牺牲一致性吗？为什么没看到？因为上面的流程图还没有考虑数据库故障或者网络故障，最后还是来一张最完整的流程图吧：</p>
<p><img src="http://ojwkevhas.bkt.clouddn.com/%E7%A7%92%E6%9D%80%E6%95%B0%E6%8D%AE%E5%BA%93sql%E8%AE%BE%E8%AE%A12.png" alt=""></p>
<p>仔细看一下整张流程图，最终就这几种情况：</p>
<ol>
<li>执行成功</li>
<li>无库存</li>
<li>回滚成功</li>
<li>损失库存</li>
</ol>
<p>前三种是正常的，只有“损失库存”是有问题的。其实，“损失库存”这种情况其实很难出现，只有在网络故障或者数据库的情况下才可能偶尔。</p>
<p>那你的业务可以容忍它吗？最终还是具体问题具体分析了。</p>
<h4 id="不要过度优化"><a href="#不要过度优化" class="headerlink" title="不要过度优化"></a>不要过度优化</h4><p>最后还是提醒一句，千万不要过度优化，第一个使用事务的方案其实已经够好了！</p>
<p>除非你的业务特殊，全中国几十万人几百万人会同时来买，那才有必要牺牲一下一致性提升性能。</p>
<p>对了，如果是像双十一或者小米这样子的抢购，上面的方案也是不够的…</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/23/%E7%A7%92%E6%9D%80%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AE%BE%E8%AE%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>高性能、最终一致性的数据同步方案</title>
      <link>http://Melodylican.github.io/2017/11/23/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</link>
      <guid>http://Melodylican.github.io/2017/11/23/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Wed, 22 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;问题的来源&lt;br&gt;先描述一下问题：&lt;/p&gt;
&lt;p&gt;两个系统的数据需要做数据同步，可以是数据库到数据库，也可以是数据库到内存。要求高性能（速度快），最终一致性（数据不能错）。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>问题的来源<br>先描述一下问题：</p>
<p>两个系统的数据需要做数据同步，可以是数据库到数据库，也可以是数据库到内存。要求高性能（速度快），最终一致性（数据不能错）。<br><a id="more"></a></p>
<p>利用 Job 来定时同步数据<br>首先，如果是中小型系统，可以接受秒级别的延时，数据变更频率不是非常高的话，可以用这个方案。</p>
<p>常见的场景有：后台系统用户数据，后台系统角色、组织架构数据。</p>
<p>Job 处理过程</p>
<p>那 Job 的数据逻辑是怎么样的呢？</p>
<p>查询数据 -&gt; 可能需要做一些转换 -&gt; 然后插入数据</p>
<p>看上去好简单的样子，但是如何查询数据会是一个挑战。因为假如你的表很大，而实际每分钟只会变更几条，难道你每次都要全量同步一边？</p>
<p>如何识别出那些变过的数据呢？</p>
<p>为你的数据加上 UpdateTime 字段</p>
<p>为了解决这个问题，需要对你的数据库表进行一定的改造。其实，所有的数据库表都应该这么设计。</p>
<p>第一个要改造的点是加上一个UpdateTime字段，每次更新数据的时候都需要去更新这个字段。</p>
<p>如果用的是 MySQL 的话，可以直接把这个字段定义成这样子：</p>
<p>UpdateTime timestamp NOT NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP</p>
<p>这样设置以后，每次数据变更 MySQL 会自动更新这个字段。另外，如果你进行了Update操作而数据其实没变，那么这个字段不会更新，非常贴心。</p>
<p>这个是为了解决什么问题？</p>
<p>我必须要知道所有数据的变更时间，我才能找到那些新插入或者新更新的数据。所以加上这个字段后，Insert和Update的问题就解决了，但是还有Delete！</p>
<p>为你的数据加上 IsDeleted 字段</p>
<p>你还在直接删除数据？如果是的话，赶紧改改吧，因为这么做在 ETL 系统中非常不友好。源表中的数据都删了，那 Job 还怎么找到它？难道要做两遍的数据比对？这个又要全表扫描目标表了。性能会非常差。</p>
<p>所以最简单的方案就是加上IsDeleted字段进行软删除，这样删除的数据其实就是Update了一下，处理起来就非常简单了。</p>
<p>如果你的系统在设计之初就用了软删除，那么你会轻松很多，如果不是，那么就需要修改你的程序了。</p>
<p>相信我，越早改越好！除非你的系统永远那么小…</p>
<p>选择合适的时间</p>
<p>下面一个问题才是真正头疼的地方。我们也用过很多现成的 ETL 系统来同步数据了，源表也加上了上面提到的两个字段来识别有变更的数据。</p>
<p>假设作业5分钟跑一次，那怎么写 SQL 语句呢？</p>
<p>SELECT * FROM User WHERE UpdateTime &gt;= DATE_SUB(Now(),INTERVAL 5 MINUTE)</p>
<p>这么写有什么缺点呢？第一个缺点就是，你没办法保证你的 Job 真的是5分钟运行一次的，如果是5分01秒呢？那多出来的1秒的数据就丢了。</p>
<p>另外，如果你 Job 所在机器的时间和数据库的时间不一致呢？极端情况假设你的 Job 机器快了10分钟，那么 Job 就永远取不到数据了。别以为这种情况不会发生…</p>
<p>这个方案直接被拍死，那么下一个方案：</p>
<p>SELECT * FROM User WHERE UpdateTime &gt;= #LastRunTime#</p>
<p>这里需要加入一个LastRunTime变量，直接变量由 Job 程序自己记录。加上这个变量后，就解决了 Job 没办法准确地5分钟跑一次的问题。</p>
<p>但是机器时间不一致的问题解决了吗？好像还没有…</p>
<p>那来一个终极完美的方案吧：</p>
<p>SELECT * FROM User WHERE UpdateTime &gt;= #LastRowTime#</p>
<p>这里的LastRowTime是什么含义呢？它是你上次取到数据的最新一条。恩，这样就完全不依赖 Job 所在机器的时间了。哪怕它们相隔几年，数据也不会丢。因为你用的是相对时间。</p>
<p>那为什么是&gt;=而不是&gt;呢？</p>
<p>极端情况下，假设在同一个时间插入两条数据，它们的LastUpdateTime是一样的。而你取数据的时候，只插入了第一条，取完了才插入第二条。如果你后面查询的时候用&gt;，这个这里第二条数据就丢掉了。</p>
<p>最后，还有一个折中方案，因为很多现成的 ETL 系统没办法记录LastRowTime，只能记录LastRunTime，那么可以这么写：</p>
<p>SELECT * FROM User WHERE UpdateTime &gt;= DATE_SUB(#LastRunTime#,INTERVAL 10 MINUTE)</p>
<p>这里我们可以接受两台机器有时间差，但是最多十分钟，这样做也会有缺点，每次都会有一些数据重复同步。</p>
<p>或者，你的 ETL 系统连LastRunTime都没有（那还算是一个合格的 ETL 系统吗？），那么只能这样了，每五分钟同步一次：</p>
<p>SELECT * FROM User WHERE UpdateTime &gt;= DATE_SUB(NOW(),INTERVAL 10 MINUTE)</p>
<p>利用阿里巴巴开源组件 canal<br>上面的方案虽说只支持中小型系统，但是你们的数据库表真的会有频繁变更吗？如果没有，那么上面的方案一直是适用的。</p>
<p>但是如果你们系统的更新真的非常频繁，而且你们要接近实时的同步效率那怎么办？</p>
<p>如果有这样需求的话，建议尝试看看阿里巴巴的canal，项目地址在这里：<a href="https://github.com/alibaba/canal" target="_blank" rel="external">https://github.com/alibaba/canal</a></p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/23/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>浅谈Java动态代理</title>
      <link>http://Melodylican.github.io/2017/11/21/%E6%B5%85%E8%B0%88Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link>
      <guid>http://Melodylican.github.io/2017/11/21/%E6%B5%85%E8%B0%88Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid>
      <pubDate>Mon, 20 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;AOP的拦截功能是由java中的动态代理来实现的。说白了，就是在目标类的基础上增加切面逻辑，生成增强的目标类（该切面逻辑或者在目标类函数执行之前，或者目标类函数执行之后，或者在目标类函数抛出异常时候执行。不同的切入时机对应不同的Interceptor的种类，如BeforeAdviseInterceptor，AfterAdviseInterceptor以及ThrowsAdviseInterceptor等）。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>AOP的拦截功能是由java中的动态代理来实现的。说白了，就是在目标类的基础上增加切面逻辑，生成增强的目标类（该切面逻辑或者在目标类函数执行之前，或者目标类函数执行之后，或者在目标类函数抛出异常时候执行。不同的切入时机对应不同的Interceptor的种类，如BeforeAdviseInterceptor，AfterAdviseInterceptor以及ThrowsAdviseInterceptor等）。<br><a id="more"></a><br>那么动态代理是如何实现将切面逻辑（advise）织入到目标类方法中去的呢？下面我们就来详细介绍并实现AOP中用到的两种动态代理。<br>AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。。</p>
<h2 id="1、定义接口和实现"><a href="#1、定义接口和实现" class="headerlink" title="1、定义接口和实现"></a>1、定义接口和实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.service;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.service.impl;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.test.service.UserService;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"------getName------"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"Tom"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"------getAge------"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、jdk动态代理实现"><a href="#2、jdk动态代理实现" class="headerlink" title="2、jdk动态代理实现"></a>2、jdk动态代理实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.jdk;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object target;</div><div class="line"></div><div class="line">    MyInvocationHandler() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MyInvocationHandler(Object target) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="string">"getName"</span>.equals(method.getName()))&#123;</div><div class="line">            System.out.println(<span class="string">"++++++before "</span> + method.getName() + <span class="string">"++++++"</span>);</div><div class="line">            Object result = method.invoke(target, args);</div><div class="line">            System.out.println(<span class="string">"++++++after "</span> + method.getName() + <span class="string">"++++++"</span>);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            Object result = method.invoke(target, args);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.jdk;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.test.service.UserService;</div><div class="line"><span class="keyword">import</span> com.test.service.impl.UserServiceImpl;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</div><div class="line">        InvocationHandler invocationHandler = <span class="keyword">new</span> MyInvocationHandler(userService);</div><div class="line">        UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),</div><div class="line">                userService.getClass().getInterfaces(), invocationHandler);</div><div class="line">        System.out.println(userServiceProxy.getName(<span class="number">100</span>));</div><div class="line">        System.out.println(userServiceProxy.getAge(<span class="number">100</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">运行结果</div><div class="line">++++++before getName++++++</div><div class="line">------getName------</div><div class="line">++++++after getName++++++</div><div class="line">Tom</div><div class="line">------getAge------</div><div class="line">10</div></pre></td></tr></table></figure>
<h2 id="3、cglib动态代理实现"><a href="#3、cglib动态代理实现" class="headerlink" title="3、cglib动态代理实现"></a>3、cglib动态代理实现</h2><p>Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：</p>
<p>CGLIB的核心类：<br>    net.sf.cglib.proxy.Enhancer – 主要的增强类<br>    net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现<br>    net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：<br>    Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。</p>
<p>net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法<br>public Object intercept(Object object, java.lang.reflect.Method method,<br>Object[] args, MethodProxy proxy) throws Throwable;</p>
<p>第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.cglib;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"++++++before "</span> + methodProxy.getSuperName() + <span class="string">"++++++"</span>);</div><div class="line">        System.out.println(method.getName());</div><div class="line">        Object o1 = methodProxy.invokeSuper(o, args);</div><div class="line">        System.out.println(<span class="string">"++++++before "</span> + methodProxy.getSuperName() + <span class="string">"++++++"</span>);</div><div class="line">        <span class="keyword">return</span> o1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.cglib;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.test.service.UserService;</div><div class="line"><span class="keyword">import</span> com.test.service.impl.UserServiceImpl;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</div><div class="line"></div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">        enhancer.setSuperclass(UserServiceImpl.class);</div><div class="line">        enhancer.setCallback(cglibProxy);</div><div class="line"></div><div class="line">        UserService o = (UserService)enhancer.create();</div><div class="line">        o.getName(<span class="number">1</span>);</div><div class="line">        o.getAge(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">++++++before CGLIB$getName$0++++++</div><div class="line">getName</div><div class="line">------getName------</div><div class="line">++++++before CGLIB$getName$0++++++</div><div class="line">++++++before CGLIB$getAge$1++++++</div><div class="line">getAge</div><div class="line">------getAge------</div><div class="line">++++++before CGLIB$getAge$1++++++</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/21/%E6%B5%85%E8%B0%88Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>浅谈分布式锁</title>
      <link>http://Melodylican.github.io/2017/11/17/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <guid>http://Melodylican.github.io/2017/11/17/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <pubDate>Thu, 16 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着互联网技术的不断发展，数据量的不断增加，业务逻辑日趋复杂，在这种背景下，传统的集中式系统已经无法满足我们的业务需求，分布式系统被应用在更多的场景，而在分布式系统中访问共享资源就需要一种互斥机制，来防止彼此之间的互相干扰，以保证一致性，在这种情况下，我们就需要用到分布式锁。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着互联网技术的不断发展，数据量的不断增加，业务逻辑日趋复杂，在这种背景下，传统的集中式系统已经无法满足我们的业务需求，分布式系统被应用在更多的场景，而在分布式系统中访问共享资源就需要一种互斥机制，来防止彼此之间的互相干扰，以保证一致性，在这种情况下，我们就需要用到分布式锁。<br><a id="more"></a></p>
<h2 id="分布式一致性问题"><a href="#分布式一致性问题" class="headerlink" title="分布式一致性问题"></a>分布式一致性问题</h2><p>首先我们先来看一个小例子：</p>
<p>假设某商城有一个商品库存剩10个，用户A想要买6个，用户B想要买5个，在理想状态下，用户A先买走了6了，库存减少6个还剩4个，此时用户B应该无法购买5个，给出数量不足的提示；而在真实情况下，用户A和B同时获取到商品剩10个，A买走6个，在A更新库存之前，B又买走了5个，此时B更新库存，商品还剩5个，这就是典型的电商“秒杀”活动。</p>
<p>从上述例子不难看出，在高并发情况下，如果不做处理将会出现各种不可预知的后果。那么在这种高并发多线程的情况下，解决问题最有效最普遍的方法就是给共享资源或对共享资源的操作加一把锁，来保证对资源的访问互斥。在Java JDK已经为我们提供了这样的锁，利用ReentrantLcok或者synchronized，即可达到资源互斥访问的目的。但是在分布式系统中，由于分布式系统的分布性，即多线程和多进程并且分布在不同机器中，这两种锁将失去原有锁的效果，需要我们自己实现分布式锁——分布式锁。</p>
<h2 id="分布式锁需要具备哪些条件"><a href="#分布式锁需要具备哪些条件" class="headerlink" title="分布式锁需要具备哪些条件"></a>分布式锁需要具备哪些条件</h2><ol>
<li>获取锁和释放锁的性能要好</li>
<li>判断是否获得锁必须是原子性的，否则可能导致多个请求都获取到锁</li>
<li>网络中断或宕机无法释放锁时，锁必须被清楚，不然会发生死锁</li>
<li>可重入一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁；</li>
</ol>
<p>5.阻塞锁和非阻塞锁，阻塞锁即没有获取到锁，则继续等待获取锁；非阻塞锁即没有获取到锁后，不继续等待，直接返回锁失败。</p>
<h2 id="分布式锁实现方式"><a href="#分布式锁实现方式" class="headerlink" title="分布式锁实现方式"></a>分布式锁实现方式</h2><h3 id="一、数据库锁"><a href="#一、数据库锁" class="headerlink" title="一、数据库锁"></a>一、数据库锁</h3><ol>
<li>基于MySQL锁表</li>
</ol>
<p>该实现方式完全依靠数据库唯一索引来实现，当想要获得锁时，即向数据库中插入一条记录，释放锁时就删除这条记录。这种方式存在以下几个问题：</p>
<p>(1) 锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁，因为唯一索引insert都会返回失败。</p>
<p>(2) 只能是非阻塞锁，insert失败直接就报错了，无法进入队列进行重试</p>
<p>(3) 不可重入，同一线程在没有释放锁之前无法再获取到锁</p>
<ol>
<li>采用乐观锁增加版本号</li>
</ol>
<p>根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。</p>
<h3 id="二、缓存锁"><a href="#二、缓存锁" class="headerlink" title="二、缓存锁"></a>二、缓存锁</h3><p><strong>这里我们主要介绍几种基于redis实现的分布式锁</strong>：</p>
<ol>
<li>基于setnx、expire两个命令来实现</li>
</ol>
<p>基于setnx（set if not exist）的特点，当缓存里key不存在时，才会去set，否则直接返回false。如果返回true则获取到锁，否则获取锁失败，为了防止死锁，我们再用expire命令对这个key设置一个超时时间来避免。但是这里看似完美，实则有缺陷，当我们setnx成功后，线程发生异常中断，expire还没来的及设置，那么就会产生死锁。</p>
<p><strong>解决上述问题有两种方案</strong></p>
<p>第一种是采用redis2.6.12版本以后的set，它提供了一系列选项</p>
<p>EX seconds – 设置键key的过期时间，单位时秒</p>
<p>PX milliseconds – 设置键key的过期时间，单位时毫秒</p>
<p>NX – 只有键key不存在的时候才会设置key的值</p>
<p>XX – 只有键key存在的时候才会设置key的值</p>
<p>第二种采用setnx()，get()，getset()实现，大体的实现过程如下：</p>
<p>(1) 线程Asetnx，值为超时的时间戳(t1)，如果返回true，获得锁。</p>
<p>(2) 线程B用get 命令获取t1，与当前时间戳比较，判断是否超时，没超时false，如果已超时执行步骤3</p>
<p>(3) 计算新的超时时间t2，使用getset命令返回t3(这个值可能其他线程已经修改过)，如果t1==t3,获得锁,如果t1!=t3说明锁被其他线程获取了</p>
<p>(4) 获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）</p>
<ol>
<li>RedLock算法</li>
</ol>
<p>redlock算法是redis作者推荐的一种分布式锁实现方式，算法的内容如下：</p>
<p>(1) 获取当前时间；</p>
<p>(2) 尝试从5个相互独立redis客户端获取锁；</p>
<p>(3) 计算获取所有锁消耗的时间，当且仅当客户端从多数节点获取锁，并且获取锁的时间小于锁的有效时间，认为获得锁；</p>
<p>(4) 重新计算有效期时间，原有效时间减去获取锁消耗的时间；</p>
<p>(5) 删除所有实例的锁</p>
<p>redlock算法相对于单节点redis锁可靠性要更高，但是实现起来条件也较为苛刻。</p>
<p>(1) 必须部署5个节点才能让Redlock的可靠性更强。</p>
<p>(2) 需要请求5个节点才能获取到锁，通过Future的方式，先并发向5个节点请求，再一起获得响应结果，能缩短响应时间，不过还是比单节点redis锁要耗费更多时间。</p>
<p>然后由于必须获取到5个节点中的3个以上，所以可能出现获取锁冲突，即大家都获得了1-2把锁，结果谁也不能获取到锁，这个问题，redis作者借鉴了raft算法的精髓，通过冲突后在随机时间开始，可以大大降低冲突时间，但是这问题并不能很好的避免，特别是在第一次获取锁的时候，所以获取锁的时间成本增加了。</p>
<p>如果5个节点有2个宕机，此时锁的可用性会极大降低，首先必须等待这两个宕机节点的结果超时才能返回，另外只有3个节点，客户端必须获取到这全部3个节点的锁才能拥有锁，难度也加大了。</p>
<p>如果出现网络分区，那么可能出现客户端永远也无法获取锁的情况，介于这种情况，下面我们来看一种更可靠的分布式锁zookeeper锁。</p>
<h3 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h3><p>首先我们来了解一下zookeeper的特性，看看它为什么适合做分布式锁，zookeeper是一个为分布式应用提供一致性服务的软件，它内部是一个分层的文件系统目录树结构，规定统一个目录下只能有一个唯一文件名。</p>
<p><strong>数据模型</strong>：</p>
<p>永久节点：节点创建后，不会因为会话失效而消失</p>
<p>临时节点：与永久节点相反，如果客户端连接失效，则立即删除节点</p>
<p>顺序节点：与上述两个节点特性类似，如果指定创建这类节点时，zk会自动在节点名后加一个数字后缀，并且是有序的。</p>
<p><strong>监视器（watcher）</strong>：</p>
<p>当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时，watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次。</p>
<p>根据zookeeper的这些特性，我们来看看如何利用这些特性来实现分布式锁：</p>
<ol>
<li>创建一个锁目录lock</li>
<li>希望获得锁的线程A就在lock目录下，创建临时顺序节点</li>
<li>获取锁目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁</li>
<li>线程B获取所有节点，判断自己不是最小节点，设置监听(watcher)比自己次小的节点（只关注比自己次小的节点是为了防止发生“羊群效应”）</li>
<li>线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是最小的节点，获得锁。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在分布式系统中，共享资源互斥访问问题非常普遍，而针对访问共享资源的互斥问题，常用的解决方案就是使用分布式锁，这里只介绍了几种常用的分布式锁，分布式锁的实现方式还有有很多种，根据业务选择合适的分布式锁，下面对上述几种锁进行一下比较：</p>
<p>数据库锁：</p>
<p><strong>优点</strong>：直接使用数据库，使用简单。</p>
<p><strong>缺点</strong>：分布式系统大多数瓶颈都在数据库，使用数据库锁会增加数据库负担。</p>
<p>缓存锁：</p>
<p><strong>优点</strong>：性能高，实现起来较为方便，在允许偶发的锁失效情况，不影响系统正常使用，建议采用缓存锁。</p>
<p><strong>缺点</strong>：通过锁超时机制不是十分可靠，当线程获得锁后，处理时间过长导致锁超时，就失效了锁的作用。</p>
<p>zookeeper锁：</p>
<p><strong>优点</strong>：不依靠超时时间释放锁；可靠性高；系统要求高可靠性时，建议采用zookeeper锁。</p>
<p><strong>缺点</strong>：性能比不上缓存锁，因为要频繁的创建节点删除节点。</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/17/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Netty 架构原理图</title>
      <link>http://Melodylican.github.io/2017/11/17/Netty%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E5%9B%BE/</link>
      <guid>http://Melodylican.github.io/2017/11/17/Netty%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E5%9B%BE/</guid>
      <pubDate>Thu, 16 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://ojwkevhas.bkt.clouddn.com/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;
      
      </description>
      
      <content:encoded><![CDATA[<center><br><img src="http://ojwkevhas.bkt.clouddn.com/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt=""><br></center>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/17/Netty%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E5%9B%BE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM内存回收算法</title>
      <link>http://Melodylican.github.io/2017/11/06/JVM%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</link>
      <guid>http://Melodylican.github.io/2017/11/06/JVM%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</guid>
      <pubDate>Sun, 05 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;上一篇说了虚拟机的内存模型，在说到堆内存的时候我们提到了，堆内存是Java内存中区域最大的一部分，而且垃圾回收器主要就是回收这部分的内容。那么这篇就来介绍一下垃圾回收器的原理以及回收的算法。&lt;/p&gt;
&lt;p&gt;Java中的垃圾回收器(GC)是Java中比较有特色的一点，不需要我们手动的去管理一个对象，不想C++中的构造函数和析构函数一样，需要程序猿自己去手动的管理，很容易造成内存泄露的问题。当然如果学过OC语言的话，我们知道OC语言中有自动释放池的概念，当然我们使用retain/release进行手动管理对象的。所以从这方面我们可以看到Android(Java)在这方面和IOS(OC)相比的话，比较卡，因为Java中的垃圾回收器是需要算法计算的，这个可能会有点耗时，但是好处就是不需要人工管理。但是OC是需要手动管理的，这样系统就不需要复杂的算法去进行管理，运行速度就比Android流畅(当然IOS比Android流畅，有很多原因的，这个只是一方面内容)&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>上一篇说了虚拟机的内存模型，在说到堆内存的时候我们提到了，堆内存是Java内存中区域最大的一部分，而且垃圾回收器主要就是回收这部分的内容。那么这篇就来介绍一下垃圾回收器的原理以及回收的算法。</p>
<p>Java中的垃圾回收器(GC)是Java中比较有特色的一点，不需要我们手动的去管理一个对象，不想C++中的构造函数和析构函数一样，需要程序猿自己去手动的管理，很容易造成内存泄露的问题。当然如果学过OC语言的话，我们知道OC语言中有自动释放池的概念，当然我们使用retain/release进行手动管理对象的。所以从这方面我们可以看到Android(Java)在这方面和IOS(OC)相比的话，比较卡，因为Java中的垃圾回收器是需要算法计算的，这个可能会有点耗时，但是好处就是不需要人工管理。但是OC是需要手动管理的，这样系统就不需要复杂的算法去进行管理，运行速度就比Android流畅(当然IOS比Android流畅，有很多原因的，这个只是一方面内容)<br><a id="more"></a></p>
<h2 id="Java中是如何管理对象的"><a href="#Java中是如何管理对象的" class="headerlink" title="Java中是如何管理对象的"></a>Java中是如何管理对象的</h2><p>在堆中存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”</p>
<p>这里就介绍两种方式来管理对象</p>
<h3 id="第一、引用计数算法"><a href="#第一、引用计数算法" class="headerlink" title="第一、引用计数算法"></a>第一、引用计数算法</h3><p>这种算法很简单的，而且也是比较常用的一种方式管理对象了</p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1，当引用失效时，计数器的值就减1，任何时刻计数器为0的对象就是不可能在被使用了，这种算法是很简单的，而且早期很多面向对象语言中都采用这种方式，但是现在主流的Java虚拟机中并没有采用这种方式来管理对象，其原因最主要的原因是它很难解决对象之间的相互循环引用。例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		Demo demo1 = <span class="keyword">new</span> Demo();</div><div class="line">		Demo demo2 = <span class="keyword">new</span> Demo();</div><div class="line">		demo1.instance = demo2;</div><div class="line">		demo2.instance = demo1;</div><div class="line">		<span class="comment">//现在demo1,demo2设置null,那么demo1,demo2能否被回收呢？</span></div><div class="line">		demo1 = <span class="keyword">null</span>;</div><div class="line">		demo2 = <span class="keyword">null</span>;</div><div class="line">		<span class="comment">//手动的调用垃圾回收器回收</span></div><div class="line">		System.gc();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Demo对象中有一个变量instance，当我们new了两个Demo对象的时候，彼此相关联，当我们将他们设置null,实际上这两个对象已经不可能被访问，但是他们因为互相引用着对方，导致它们的引用计数不为0，于是引用计数算法无法通知GC收集器回收它们。这有点类似于并发中的死锁。</p>
<p>所以解决上面存在的问题，第二种方式就出现了。</p>
<h3 id="第二、可达性分析算法"><a href="#第二、可达性分析算法" class="headerlink" title="第二、可达性分析算法"></a>第二、可达性分析算法</h3><p>这个算法的基本思路就是通过一系列的称谓“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径为引用链，当一个对象到GC Roots没有任何引用链项链时，则证明此对象时不可用的，下面看一下例子：</p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%951.png" alt=""><br><br></center>

<p>上面的这张图，对象object5、object6、object7虽然互相没有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象</p>
<p><strong>注</strong>：Java语言中，可作为GC Roots的对象包括下面几种：</p>
<p>1) 虚拟机栈(栈帧中的本地变量表)中引用的对象</p>
<p>2) 方法区中类静态属性引用的对象</p>
<p>3) 方法区中常量引用的对象</p>
<p>4) 本地方法栈中JNI(即一般说的Native方法)引用的对象</p>
<h2 id="Java中的引用类型"><a href="#Java中的引用类型" class="headerlink" title="Java中的引用类型"></a>Java中的引用类型</h2><p>从JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用，这四种引用的强度一次逐渐减弱</p>
<p>1) 强引用就是指在程序代码之中普遍存在的，类似 “Object obj = new Object()” 这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</p>
<p>2) 软引用是用来描述一些还有用但并非需要的对象，对于软引用关联着的对象，在系统将要发生内存异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存异常</p>
<p>3) 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存岛下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存释放足够，都会回收掉只被弱引用关联的对象</p>
<p>4) 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，对一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</p>
<p><strong>垃圾收集算法</strong></p>
<h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1) 标记-清除算法"></a>1) 标记-清除算法</h3><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 标记-清除算法的执行过程如图</p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%952.jpg" alt=""><br><br></center>


<h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2) 复制算法"></a>2) 复制算法</h3><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。复制算法的执行过程如图</p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%953.jpg" alt=""><br></center>


<p>3) 标记-整理算法</p>
<p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图</p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%954.jpg" alt=""><br></center>


<p>4) 分代收集算法</p>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收</p>
<center><br><img src="http://ojwkevhas.bkt.clouddn.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%955.png" alt=""><br></center>

<h2 id="Java虚拟机对堆的内存细化的几个区域，并且这些区域都是采用哪些收集算法"><a href="#Java虚拟机对堆的内存细化的几个区域，并且这些区域都是采用哪些收集算法" class="headerlink" title="Java虚拟机对堆的内存细化的几个区域，并且这些区域都是采用哪些收集算法"></a>Java虚拟机对堆的内存细化的几个区域，并且这些区域都是采用哪些收集算法</h2><p>JVM内存模型中分两大块，一块是New Generation, 另一块是Old Generation. 在New Generation中，有一个叫Eden的空间，主要是用来存放新生的对象，还有两个Survivor Spaces（from,to）, 它们用来存放每次垃圾回收后存活下来的对象。在Old Generation中，主要存放应用程序中生命周期长的内存对象，还有个Permanent Generation，主要用来放JVM自己的反射对象，比如类对象和方法对象等。<br>1) 在New Generation块中，垃圾回收一般用复制算法，速度快。每次GC的时候，存活下来的对象首先由Eden拷贝到某个Survivor Space, 当Survivor Space空间满了后, 剩下的live对象就被直接拷贝到Old Generation中去。因此，每次GC后，Eden内存块会被清空</p>
<p>2) 在Old Generation块中，垃圾回收一般用标记整理的算法，速度慢些，但减少内存要求.</p>
<p>垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收Old段中的垃圾；1级或以上为部分垃圾回收，只会回收New中的垃圾，内存溢出通常发生于Old段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。</p>
<p>Out Of Memory 只发生在jvm对old和perm generation 回收后还不能获足够内存的情况.<br>当生成一个新对象时，内存申请过程如下：<br>A. JVM会试图为相关Java对象在Eden中初始化一块内存区域<br>B. 当Eden空间足够时，内存申请结束。否则到下一步<br>C. JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）, 释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区<br>D. Survivor区被用来作为Eden及Old的中间交换区域，当Old区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区<br>E. 当Old区空间不够时，JVM会在Old区进行完全的垃圾收集（0级）<br>F. 完全垃圾收集后，若Survivor及Old区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”</p>
<p>造成full gc的原因<br>new了很多对象,没有即时在主动释放掉-&gt;Eden内存不够用-&gt;不断把对象往old迁移-&gt;old满了-&gt;full gc</p>
<p><strong>总结</strong>：上面的内容就介绍了Java虚拟机如何管理对象的，我们也看到了上面主要就是收集算法和堆空间的从新划分，这样做的目的都是在于垃圾回收的高效执行，但是总归看来，如果对象交给系统来管理，在系统运行的过程效率肯定会有影响的，但是这有一点比较好，就是不需要手动管理，给程序猿带来方便。</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/06/JVM%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM内存模型</title>
      <link>http://Melodylican.github.io/2017/11/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <guid>http://Melodylican.github.io/2017/11/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <pubDate>Sat, 04 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;今天闲来无事来，看一下Java中的内存模型和垃圾回收机制的原理，关于这个方面的知识，网上已经有很多现成的资料可以供我们参考，但是知识还是比较杂的，在这部分知识点中有一本书不得不推荐：《深入理解Java虚拟机》，现在已经是第二版了。这本书就从头开始详细介绍了Java整个虚拟机的模型以及Java的类文件结构，加载机制等。这里大部分的知识点都是可以在这本书中找到的，当然我是主要还是借鉴这本书中的很多内容的。下面就不多说了，进入主题吧。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今天闲来无事来，看一下Java中的内存模型和垃圾回收机制的原理，关于这个方面的知识，网上已经有很多现成的资料可以供我们参考，但是知识还是比较杂的，在这部分知识点中有一本书不得不推荐：《深入理解Java虚拟机》，现在已经是第二版了。这本书就从头开始详细介绍了Java整个虚拟机的模型以及Java的类文件结构，加载机制等。这里大部分的知识点都是可以在这本书中找到的，当然我是主要还是借鉴这本书中的很多内容的。下面就不多说了，进入主题吧。<br><a id="more"></a><br>首先来看一下Java中的内存模型图：</p>
<p><center><br><img src="http://ojwkevhas.bkt.clouddn.com/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B1.jpg" alt=""><br></center></p>
<h2 id="程序计数器-PC"><a href="#程序计数器-PC" class="headerlink" title="程序计数器(PC)"></a>程序计数器(PC)</h2><p>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看做当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来取下一条需要执行的字节码指令，分支、跳转、循环、异常处理、线程恢复等基础功能都需要这个计数器来完成</p>
<p><strong>注</strong>：程序计数器是线程私有的，每条线程都会有一个独立的程序计数器</p>
<h2 id="Java栈-虚拟机栈"><a href="#Java栈-虚拟机栈" class="headerlink" title="Java栈(虚拟机栈)"></a>Java栈(虚拟机栈)</h2><p>Java栈就是Java中的方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧(关于栈帧后面介绍)，这个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p><strong>注</strong>：Java栈也是线程私有的。</p>
<p>异常可能性：对于栈有两种异常情况：如果线程请求的栈深度大于栈所允许的深度，将抛出StackOverflowError异常，如果虚拟机栈可以动态拓展，在拓展的时无法申请到足够的内存，将会抛出OutOfMemoryError异常</p>
<p>栈帧的概念：</p>
<p><center><br><img src="http://ojwkevhas.bkt.clouddn.com/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png" alt=""><br></center><br>栈帧用于支持虚拟机进行方法调用和执行的数据结构。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表（Local Variable Table）是一组 变量值存储空间，用于存放 方法参数和方法内部定义的局部变量.局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位. 一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference[3]和returnAddress 8种类型,对于 64位的数据类型，虚拟机会以高位对齐的方式为其 分配两个连续的Slot空间(long double).</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out,LIFO）栈，当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作，例如，在做算术运算的时候通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p>
<p>举个例子：整数假发的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int类型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>一个方法开始执行后，只有 两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为 正常完成出口（Normal Method Invocation Completion）。另外一种退出方式是，在方法执行过程中 遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为 异常完成出口（Abrupt Method Invocation Completion）。 一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的  </p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与Java栈所发挥的作用是非常相似的，它们之间的区别不过是Java栈执行Java方法，本地方法栈执行的是本地方法。</p>
<p><strong>注</strong>：本地方法栈也是线程私有的</p>
<p>异常可能性：和Java栈一样，可能抛出StackOverflowError和OutOfMemeryError异常</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，当然我们后面说到的垃圾回收器的内容的时候，其实Java堆就是垃圾回收器管理的主要区域。</p>
<p><strong>注</strong>：堆是线程共享的</p>
<p>异常可能性：如果堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出<strong>OutOfMemeryError</strong>异常</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区它用于存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。</p>
<p><strong>注</strong>：方法区和堆一样是线程共享的</p>
<p>异常可能性：当方法区无法满足内存分配需求时，将抛出<strong>OutOfMemeryError</strong>异常</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载器后进入方法区的运行时异常常量池存放。</p>
<p>上面就介绍了Java的内存的几个模块的相关概念，其实我们需要知道这些知识，最主要的目的是不要在项目中写那些OOM的代码，因为我们如果知道了内存模型之后，即使代码中出现了OOM的问题，我们可以定位到哪里出了问题。</p>
<p><strong>下面也来看一下上面说到的几个内存模块导致的内存溢出异常问题：</strong></p>
<h2 id="内存模块导致的内存溢出异常问题"><a href="#内存模块导致的内存溢出异常问题" class="headerlink" title="内存模块导致的内存溢出异常问题"></a>内存模块导致的内存溢出异常问题</h2><p>(这个也是面试的时候经常会被问到：比如叫你写一段让堆内存溢出的代码，或者是问你如果如果修改堆大小)</p>
<h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</div><div class="line">		</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			list.add(<span class="keyword">new</span> OOMObject());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们上面看到堆主要是存放对象的，所以我们如果想让堆出现OOM的话，可以开一个死循环，然后产生新的对象就可以了。然后在将堆的大小调小点。</p>
<p>加上JVM参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-verbose:gc -Xms10M -Xmx10M -XX:+PrintGCDetails -XX:SurvivorRatio=<span class="number">8</span> -XX:+HeapDumpOnOutOfMemoryError，</div></pre></td></tr></table></figure></p>
<p>就能很快报出OOM：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</div></pre></td></tr></table></figure></p>
<h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.cutesource;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOOM</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</div><div class="line">		stackLength++;</div><div class="line">		stackLeak();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		StackOOM oom = <span class="keyword">new</span> StackOOM();</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			oom.stackLeak();</div><div class="line">		&#125;<span class="keyword">catch</span>(Throwable err)&#123;</div><div class="line">			System.out.println(<span class="string">"Stack length:"</span> + oom.stackLength);</div><div class="line">			<span class="keyword">throw</span> err;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道栈中存放的方法执行的过程中需要的空间，所以我们可以下一个循环递归，这样方法栈就会出现OOM的异常了。</p>
<p>设置JVM参数：<strong>-Xss128k</strong>，报出异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exception in thread “main” java.lang.StackOverflowError</div></pre></td></tr></table></figure></p>
<p>打印出Stack length:1007，这里可以看出，在我的机器上128k的栈容量能承载深度为1007的方法调用。当然报这样的错很少见，一般只会出现无限循环的递归中，另外，线程太多也会占满栈区域：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.cutesource;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOOM</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="keyword">try</span>&#123;Thread.sleep(<span class="number">1000</span>);&#125;<span class="keyword">catch</span>(Exception err)&#123;&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line"></div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">					dontStop();</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">			&#125;);</div><div class="line">			t.start();</div><div class="line">			stackLength++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		StackOOM oom = <span class="keyword">new</span> StackOOM();</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			oom.stackLeakByThread();</div><div class="line">		&#125;<span class="keyword">catch</span>(Throwable err)&#123;</div><div class="line">			System.out.println(<span class="string">"Stack length:"</span> + oom.stackLength);</div><div class="line">			<span class="keyword">throw</span> err;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个栈的溢出，就是我们上面说到栈的时候的两种异常情况。</p>
<p>报出异常：Exception in thread “main” java.lang.OutOfMemoryError:unable to create new native thread</p>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaOOM</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMOjbect</span></span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			Enhancer eh = <span class="keyword">new</span> Enhancer();</div><div class="line">			eh.setSuperclass(OOMOjbect.class);</div><div class="line">			eh.setUseCache(<span class="keyword">false</span>);</div><div class="line">			eh.setCallback(<span class="keyword">new</span> MethodInterceptor()&#123;</div><div class="line"></div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1,</span></span></div><div class="line">						Object[] arg2, MethodProxy arg3) <span class="keyword">throws</span> Throwable &#123;</div><div class="line">					<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">					<span class="keyword">return</span> arg3.invokeSuper(arg0, arg2);</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">			&#125;);</div><div class="line">			eh.create();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道方法区是存放一些类的信息等，所以我们可以使用类加载无限循环加载class，这样就会出现方法区的OOM异常。</p>
<p>手动将栈的大小调小点</p>
<p>加上JVM参数：-XX:PermSize=10M -XX:MaxPermSize=10M，运行后会报如下异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exception in thread “main” java.lang.OutOfMemoryError: PermGen space</div></pre></td></tr></table></figure></p>
<h3 id="常量池溢出"><a href="#常量池溢出" class="headerlink" title="常量池溢出"></a>常量池溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantOOM</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			list.add(String.valueOf(i++).intern());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道常量池中存放的是运行过程中的常量，同时我们知道String类型的intern方法是将字符串的值放到常量池中的。所以上面弄可以开一个死循环将字符串的值都放到常量池中，这样常量池就会出现OOM异常了。因为常量池本身就是方法区的一部分，所以我们也可以手动的调节一下栈的大小。</p>
<p><strong>总结</strong>：上面只是从宏观的角度介绍了一下内存模型，具体关于内存中每个区域的详细信息，可以阅读开头说到的那本很不错的书籍。当然我们在学习Java的时候可以分为四大模块：Java的Api、Java虚拟机(内存模型和垃圾回收器)、Java的Class文件、设计模式，关于Api的知识我们在工作的过程中用到的比较多，而且这部分内容完全是靠使用度，你用多了，api你自然就知道了。Java虚拟机和Java的Class文件的相关知识在工作中可能不一定能用到，但是这方面的知识能够让你更了解Java的整个体系结构。至于设计模式这个就是修炼的过程，也是最难的过程。得慢慢的体会其的强大之处。</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/05/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL分库分表环境下全局ID生成方案</title>
      <link>http://Melodylican.github.io/2017/11/03/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</link>
      <guid>http://Melodylican.github.io/2017/11/03/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Thu, 02 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;MySQL分库分表环境下全局ID生成方案&quot;&gt;&lt;a href=&quot;#MySQL分库分表环境下全局ID生成方案&quot; class=&quot;headerlink&quot; title=&quot;MySQL分库分表环境下全局ID生成方案&quot;&gt;&lt;/a&gt;MySQL分库分表环境下全局ID生成方案&lt;/h1&gt;&lt;p&gt;在大型互联网应用中，随着用户数的增加，为了提高应用的性能，我们经常需要对数据库进行分库分表操作。在单表时代，我们可以完全依赖于数据库的自增 ID来唯一标识一个用户或数据对象。但是当我们对数据库进行了分库分表后，就不能依赖于每个表的自增ID来全局唯一标识这些数据了。因此，我们需要提供一 个全局唯一的ID号生成策略来支持分库分表的环境。下面来介绍两种非常优秀的解决方案：&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="MySQL分库分表环境下全局ID生成方案"><a href="#MySQL分库分表环境下全局ID生成方案" class="headerlink" title="MySQL分库分表环境下全局ID生成方案"></a>MySQL分库分表环境下全局ID生成方案</h1><p>在大型互联网应用中，随着用户数的增加，为了提高应用的性能，我们经常需要对数据库进行分库分表操作。在单表时代，我们可以完全依赖于数据库的自增 ID来唯一标识一个用户或数据对象。但是当我们对数据库进行了分库分表后，就不能依赖于每个表的自增ID来全局唯一标识这些数据了。因此，我们需要提供一 个全局唯一的ID号生成策略来支持分库分表的环境。下面来介绍两种非常优秀的解决方案：<br><a id="more"></a></p>
<h2 id="数据库自增ID——来自Flicker的解决方案"><a href="#数据库自增ID——来自Flicker的解决方案" class="headerlink" title="数据库自增ID——来自Flicker的解决方案"></a>数据库自增ID——来自Flicker的解决方案</h2><p>因为MySQL本身支持auto_increment操作，很自然地，我们会想到借助这个特性来实现这个功能。Flicker在解决全局ID生成方 案里就采用了MySQL自增长ID的机制（auto_increment + replace into + MyISAM）。一个生成64位ID方案具体就是这样的：<br>先创建单独的数据库(eg:ticket)，然后创建一个表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Tickets64 (</div><div class="line">            id bigint(20) unsigned NOT NULL auto_increment,</div><div class="line">            stub char(1) NOT NULL default &apos;&apos;,</div><div class="line">            PRIMARY KEY  (id),</div><div class="line">            UNIQUE KEY stub (stub)</div><div class="line">    ) ENGINE=MyISAM</div></pre></td></tr></table></figure></p>
<p>当我们插入记录后，执行SELECT * from Tickets64，查询结果就是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+-------------------+------+</div><div class="line">| id                | stub |</div><div class="line">+-------------------+------+</div><div class="line">| 72157623227190421 |    a |</div><div class="line">+-------------------+------+</div></pre></td></tr></table></figure></p>
<p>在我们的应用端需要做下面这两个操作，在一个事务会话里提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">REPLACE INTO Tickets64 (stub) VALUES (&apos;a&apos;);</div><div class="line">SELECT LAST_INSERT_ID();</div></pre></td></tr></table></figure></p>
<p>这样我们就能拿到不断增长且不重复的ID了。<br>到上面为止，我们只是在单台数据库上生成ID，从高可用角度考虑，接下来就要解决单点故障问题：<strong>Flicker</strong>启用了两台数据库服务器来生成ID，通过区分auto_increment的起始值和步长来生成<strong>奇偶数</strong>的ID。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">TicketServer1:</div><div class="line">auto-increment-increment = 2</div><div class="line">auto-increment-offset = 1</div><div class="line"></div><div class="line">TicketServer2:</div><div class="line">auto-increment-increment = 2</div><div class="line">auto-increment-offset = 2</div></pre></td></tr></table></figure></p>
<p>最后，在客户端只需要通过<strong>轮询方式</strong>取ID就可以了。</p>
<p><strong>优点</strong>：充分借助数据库的自增ID机制，提供高可靠性，生成的ID有序。<br><strong>缺点</strong>：占用两个独立的MySQL实例，有些浪费资源，成本较高。<br>参考：<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="external">http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/</a></p>
<h2 id="独立的应用程序——来自Twitter的解决方案"><a href="#独立的应用程序——来自Twitter的解决方案" class="headerlink" title="独立的应用程序——来自Twitter的解决方案"></a>独立的应用程序——来自Twitter的解决方案</h2><p>Twitter在把存储系统从MySQL迁移到Cassandra的过程中由于Cassandra没有顺序ID生成机制，于是自己开发了一套全局唯一ID生成服务：Snowflake。GitHub地址：<a href="https://github.com/twitter/snowflake" target="_blank" rel="external">https://github.com/twitter/snowflake</a>。根据twitter的业务需求，snowflake系统生成64位的ID。由3部分组成：</p>
<p>41位的时间序列（精确到毫秒，41位的长度可以使用69年）<br>10位的机器标识（10位的长度最多支持部署1024个节点）<br>12位的计数顺序号（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）<br>最高位是符号位，始终为0。</p>
<p><strong>优点</strong>：高性能，低延迟；独立的应用；按时间有序。<br><strong>缺点</strong>：需要独立的开发和部署。</p>
<font color="red"><strong>注</strong>：last_insert_id()的值是由MySQL server来维护的，而且是为每条连接维护独立的值，也即，某条连接调用last_insert_id()获取到的值是这条连接最近一次insert操作执行后的自增值，该值不会被其它连接的sql语句所影响。这个行为保证了不同的连接能正确地获取到它最近一次insert sql执行所插入的行的自增值，也就是说，last_insert_id()的值不需要通过加锁或事务机制来保证其在多连接场景下的正确性.</font>

<h2 id="在Twitter基础上的改进"><a href="#在Twitter基础上的改进" class="headerlink" title="在Twitter基础上的改进"></a>在Twitter基础上的改进</h2><p>可参考 <a href="http://geek.csdn.net/news/detail/72973" target="_blank" rel="external">http://geek.csdn.net/news/detail/72973</a> </p>
<h2 id="使用缓存队列"><a href="#使用缓存队列" class="headerlink" title="使用缓存队列"></a>使用缓存队列</h2><p>使用队列服务，如redis、memcacheq等等，将一定量的ID预分配在一个队列里，每次插入操作，先从队列中获取一个ID，若插入失败的话，将该ID再次添加到队列中，同时监控队列数量，当小于阀值时，自动向队列中添加元素。<br>这种方式可以有规划的对ID进行分配，还会带来经济效应，比如ＱＱ号码，各种靓号，明码标价。如网站的userid, 允许uid登陆，推出各种靓号，明码标价，对于普通的ID打乱后再随机分配。</p>
<h2 id="在Redis中使用lua脚本"><a href="#在Redis中使用lua脚本" class="headerlink" title="在Redis中使用lua脚本"></a>在Redis中使用lua脚本</h2><p>详细参见——<a href="http://blog.csdn.net/hengyunabc/article/details/19025973" target="_blank" rel="external">http://blog.csdn.net/hengyunabc/article/details/19025973</a></p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/03/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 线程间的状态转换</title>
      <link>http://Melodylican.github.io/2017/11/02/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</link>
      <guid>http://Melodylican.github.io/2017/11/02/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</guid>
      <pubDate>Wed, 01 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;线程间的状态转换： &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://ojwkevhas.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>线程间的状态转换： </p>
<p><center><br><img src="http://ojwkevhas.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg" alt=""><br></center><br><a id="more"></a></p>
<ol>
<li><p><strong>新建(new)</strong>：新创建了一个线程对象。</p>
</li>
<li><p><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p>
</li>
<li><p><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p>
</li>
<li><p><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：<br> (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</p>
<p> (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</p>
<p> (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>
</li>
<li><p><strong>死亡(dead)</strong>：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
</li>
</ol>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/02/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java技能图谱</title>
      <link>http://Melodylican.github.io/2017/11/01/java%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</link>
      <guid>http://Melodylican.github.io/2017/11/01/java%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</guid>
      <pubDate>Tue, 31 Oct 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://ojwkevhas.bkt.clouddn.com/2.1%20JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E5%9B%BE%E8%B0%B1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;
      
      </description>
      
      <content:encoded><![CDATA[<center><br><img src="http://ojwkevhas.bkt.clouddn.com/2.1%20JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E5%9B%BE%E8%B0%B1.png" alt=""><br><a id="more"></a><br><img src="http://ojwkevhas.bkt.clouddn.com/1.2%20Java%E6%9E%B6%E6%9E%84%E5%B8%88%E5%9B%BE%E8%B0%B1.jpg" alt=""><br><br><img src="http://ojwkevhas.bkt.clouddn.com/2.3%20Java%E9%9B%86%E5%90%88%E5%9B%BE%E8%B0%B1.jpg" alt=""><br><br><img src="http://ojwkevhas.bkt.clouddn.com/2.7%20Java%20Set%E7%B1%BB%E5%9B%BE.jpg" alt=""><br><br><img src="http://ojwkevhas.bkt.clouddn.com/2.5%20Java%20List%E7%B1%BB%E5%9B%BE.jpg" alt=""><br><br><img src="http://ojwkevhas.bkt.clouddn.com/2.4%20Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%BE.jpg" alt=""><br><br><img src="http://ojwkevhas.bkt.clouddn.com/2.2%20Java%E5%B9%B6%E5%8F%91%E5%9B%BE%E8%B0%B1.jpg" alt=""><br></center>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/11/01/java%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Elasticsearch日志清理脚本</title>
      <link>http://Melodylican.github.io/2017/10/20/ES%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/</link>
      <guid>http://Melodylican.github.io/2017/10/20/ES%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/</guid>
      <pubDate>Thu, 19 Oct 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;有的时候我们在使用ES时，由于资源有限或业务需求，我们只想保存最近一段时间的数据，所以有如下脚本可以定时删除数据&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>有的时候我们在使用ES时，由于资源有限或业务需求，我们只想保存最近一段时间的数据，所以有如下脚本可以定时删除数据</p>
<a id="more"></a> 
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="comment"># example: sh  delete_es_by_day.sh logstash-* logsdate 30</span></div><div class="line"></div><div class="line">index_name=<span class="variable">$1</span></div><div class="line">daycolumn=<span class="variable">$2</span></div><div class="line">savedays=<span class="variable">$3</span></div><div class="line">format_day=<span class="variable">$4</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$savedays</span>"</span> ]; <span class="keyword">then</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"the args is not right,please input again...."</span></div><div class="line">  <span class="built_in">exit</span> 1</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$format_day</span>"</span> ]; <span class="keyword">then</span></div><div class="line">   format_day=<span class="string">'%Y%m%d'</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line">sevendayago=`date <span class="_">-d</span> <span class="string">"-<span class="variable">$&#123;savedays&#125;</span> day "</span> +<span class="variable">$&#123;format_day&#125;</span>`</div><div class="line"></div><div class="line">curl -XDELETE <span class="string">"172.16.150.170:9200/<span class="variable">$&#123;index_name&#125;</span>/_query?pretty"</span> <span class="_">-d</span> <span class="string">"</span></div><div class="line">&#123;</div><div class="line">        "query<span class="string">": &#123;</span></div><div class="line">                "filtered<span class="string">": &#123;</span></div><div class="line">                        "filter<span class="string">": &#123;</span></div><div class="line">                                "bool<span class="string">": &#123;</span></div><div class="line">                                        "must<span class="string">": &#123;</span></div><div class="line">                                                "range<span class="string">": &#123;</span></div><div class="line">                                                        "<span class="variable">$&#123;daycolumn&#125;</span><span class="string">": &#123;</span></div><div class="line">                                                                "from<span class="string">": null,</span></div><div class="line">                                                                "to<span class="string">": <span class="variable">$&#123;sevendayago&#125;</span>,</span></div><div class="line">                                                                "include_lower<span class="string">": true,</span></div><div class="line">                                                                "include_upper<span class="string">": true</span></div><div class="line">                                                        &#125;</div><div class="line">                                                &#125;</div><div class="line">                                        &#125;</div><div class="line">                                &#125;</div><div class="line">                        &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">&#125;"</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"ok"</span></div></pre></td></tr></table></figure>
<p>注解：脚本传入参数说明：1.索引名；2.日期字段名；3.保留最近几天数据，单位天；4.日期格式，可不输（默认形式20171020）</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/10/20/ES%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux日志清理</title>
      <link>http://Melodylican.github.io/2017/10/16/Linux%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86%E6%97%A5%E5%BF%97/</link>
      <guid>http://Melodylican.github.io/2017/10/16/Linux%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Sun, 15 Oct 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;linux是一个很能自动产生文件的系统，日志、邮件、备份等。虽然现在硬盘廉价，我们可以有很多硬盘空间供这些文件浪费，让系统定时清理一些不需要的文件很有一种爽快的事情。不用你去每天惦记着是否需要清理日志，不用每天收到硬盘空间不足的报警短信，想好好休息的话，让我们把这个事情交给机器定时去执行吧。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>linux是一个很能自动产生文件的系统，日志、邮件、备份等。虽然现在硬盘廉价，我们可以有很多硬盘空间供这些文件浪费，让系统定时清理一些不需要的文件很有一种爽快的事情。不用你去每天惦记着是否需要清理日志，不用每天收到硬盘空间不足的报警短信，想好好休息的话，让我们把这个事情交给机器定时去执行吧。<br><a id="more"></a></p>
<p><strong>1.删除文件命令</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find 对应目录 -mtime +天数 -name &quot;文件名&quot; -exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure></p>
<p>实例命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find /opt/soft/log/ -mtime +30 -name &quot;*.log&quot; -exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure></p>
<p>说明：</p>
<p>将/opt/soft/log/目录下所有30天前带”.log”的文件删除。具体参数说明如下：</p>
<p>find：linux的查找命令，用户查找指定条件的文件；</p>
<p>/opt/soft/log/：想要进行清理的任意目录；</p>
<p>-mtime：标准语句写法；</p>
<p>+30：查找30天前的文件，这里用数字代表天数；</p>
<p>“<em>.log”：希望查找的数据类型，”</em>.jpg”表示查找扩展名为jpg的所有文件，”*”表示查找所有文件，这个可以灵活运用，举一反三；</p>
<p>-exec：固定写法；</p>
<p>rm -rf：强制删除文件，包括目录；</p>
<p>{} \; ：固定写法，一对大括号+空格++; </p>
<p><strong>2.计划任务</strong>：</p>
<p>若嫌每次手动执行语句太麻烦，可以将这小语句写到一个可执行shell脚本文件中，再设置cron调度执行，那就可以让系统自动去清理相关文件。</p>
<p><strong>2.1创建shell</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">touch /opt/soft/bin/auto-del-30-days-ago-log.sh</div><div class="line"></div><div class="line">chmod +x auto-del-30-days-ago-log.sh</div></pre></td></tr></table></figure></p>
<p>新建一个可执行文件auto-del-30-days-ago-log.sh，并分配可运行权限</p>
<p><strong>2.2编辑shell脚本</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi auto-del-30-days-ago-log.sh</div></pre></td></tr></table></figure></p>
<p>编辑auto-del-30-days-ago-log.sh文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">find /opt/soft/log/ -mtime +30 -name &quot;*.log&quot; -exec rm -rf &#123;&#125; \;</div></pre></td></tr></table></figure>
<p>ok，保存退出(:wq)。</p>
<p><strong>2.3计划任务</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#crontab -e</div></pre></td></tr></table></figure></p>
<p>将auto-del-30-days-ago-log.sh执行脚本加入到系统计划任务，到点自动执行</p>
<p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 0 * * * /opt/soft/log/auto-del-7-days-ago-log.sh</div></pre></td></tr></table></figure></p>
<p>这里的设置是每天凌晨0点10分执行auto-del-7-days-ago-log.sh文件进行数据清理任务了。</p>
<p>完成以上三步，你就再也不每天惦记是否硬盘空间满了，该清理日志文件了，再也不会受到服务器硬盘空间不足的报警信息了，放心的去看书喝咖啡去吧！</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/10/16/Linux%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86%E6%97%A5%E5%BF%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>架构之路</title>
      <link>http://Melodylican.github.io/2017/10/12/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/</link>
      <guid>http://Melodylican.github.io/2017/10/12/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/</guid>
      <pubDate>Wed, 11 Oct 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;安全优化&quot;&gt;&lt;a href=&quot;#安全优化&quot; class=&quot;headerlink&quot; title=&quot;安全优化&quot;&gt;&lt;/a&gt;安全优化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;阿里云的VPN虚拟专有网络以及安全组配置&lt;/li&gt;
&lt;li&gt;自建机房的话，要自行配置防火墙安全策略&lt;/li&gt;
&lt;li&gt;相关服务访问，比如Mysql、Redis、Solr等如果没有特殊需求尽量使用内网访问并设置鉴权&lt;/li&gt;
&lt;li&gt;尽量使用代理服务器，不要对外开放过多的端口&lt;/li&gt;
&lt;li&gt;https配合HTTP/2.0也是个不错的选择&lt;/li&gt;&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="安全优化"><a href="#安全优化" class="headerlink" title="安全优化"></a>安全优化</h2><ul>
<li>阿里云的VPN虚拟专有网络以及安全组配置</li>
<li>自建机房的话，要自行配置防火墙安全策略</li>
<li>相关服务访问，比如Mysql、Redis、Solr等如果没有特殊需求尽量使用内网访问并设置鉴权</li>
<li>尽量使用代理服务器，不要对外开放过多的端口</li>
<li>https配合HTTP/2.0也是个不错的选择<a id="more"></a>
</li>
</ul>
<h2 id="架构装逼必备词汇"><a href="#架构装逼必备词汇" class="headerlink" title="架构装逼必备词汇"></a>架构装逼必备词汇</h2><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><ul>
<li>负载均衡（负载均衡算法）</li>
<li>反向代理</li>
<li>服务隔离</li>
<li>服务限流</li>
<li>服务降级（自动优雅降级）</li>
<li>失效转移</li>
<li>超时重试</li>
<li>回滚机制</li>
</ul>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><ul>
<li>应用缓存</li>
<li>HTTP缓存</li>
<li>多级缓存</li>
<li>分布式缓存</li>
<li>连接池</li>
<li>异步并发</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><ul>
<li>二阶段提交(强一致)</li>
<li>三阶段提交(强一致)</li>
<li>消息中间件(最终一致性)，推荐阿里的RocketMQ</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>任务队列</li>
<li>消息队列</li>
<li>请求队列</li>
</ul>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul>
<li>单体垂直扩容</li>
<li>单体水平扩容</li>
<li>应用拆分</li>
<li>数据库拆分</li>
<li>数据库分库分表</li>
<li>数据异构</li>
<li>分布式任务</li>
</ul>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><ul>
<li>SQL注入</li>
<li>XSS攻击</li>
<li>CSRF攻击</li>
<li>拒绝服务（DoS，Denial　of　Service）攻击</li>
</ul>
<h2 id="架构装逼必备工具"><a href="#架构装逼必备工具" class="headerlink" title="架构装逼必备工具"></a>架构装逼必备工具</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>Linux（必备）、某软的</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>DNS、F5、LVS、Nginx、HAproxy、负载均衡SLB（阿里云）</p>
<h3 id="分布式框架"><a href="#分布式框架" class="headerlink" title="分布式框架"></a>分布式框架</h3><p>Dubbo、Motan、Spring-Could</p>
<h3 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h3><p>DRDS （阿里云）、Mycat、360 Atlas、Cobar (不维护了)</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>RabbitMQ、ZeroMQ、Redis、ActiveMQ、Kafka</p>
<h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>Zookeeper、Redis</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Redis、Oscache、Memcache、Ehcache</p>
<h3 id="集成部署"><a href="#集成部署" class="headerlink" title="集成部署"></a>集成部署</h3><p>Docker、Jenkins、Git、Maven</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>OSS、NFS、FastDFS、MogileFS</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>MySql、Redis、MongoDB、PostgreSQL、Memcache、HBase</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>专用网络VPC、弹性公网IP、CDN</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/10/12/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>解决npm install很缓慢的问题</title>
      <link>http://Melodylican.github.io/2017/10/10/%E8%A7%A3%E5%86%B3npm-install%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <guid>http://Melodylican.github.io/2017/10/10/%E8%A7%A3%E5%86%B3npm-install%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Mon, 09 Oct 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;使用NPM（Node.js包管理工具）安装依赖时速度特别慢，为了安装Express，执行命令后两个多小时都没安装成功，最后只能取消安装，笔者20M带宽，应该不是我网络的原因，后来在网上找了好久才找到一种最佳解决办法，在安装时可以手动指定从哪个镜像服务器获取资源，我们可以使用阿里巴巴在国内的镜像服务器，命令如下：&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>使用NPM（Node.js包管理工具）安装依赖时速度特别慢，为了安装Express，执行命令后两个多小时都没安装成功，最后只能取消安装，笔者20M带宽，应该不是我网络的原因，后来在网上找了好久才找到一种最佳解决办法，在安装时可以手动指定从哪个镜像服务器获取资源，我们可以使用阿里巴巴在国内的镜像服务器，命令如下：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -gd express --registry=http://registry.npm.taobao.org</div></pre></td></tr></table></figure></p>
<p>只需要使用–registry参数指定镜像服务器地址，为了避免每次安装都需要–registry参数，可以使用如下命令进行永久设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config set registry http://registry.npm.taobao.org</div></pre></td></tr></table></figure>
<p>换了国内镜像，安装速度就很快了。</p>
<p>Ubuntu16.04亲测有效。</p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/10/10/%E8%A7%A3%E5%86%B3npm-install%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Kafka offset的重置</title>
      <link>http://Melodylican.github.io/2017/09/25/kafka-offset%E7%9A%84%E9%87%8D%E7%BD%AE/</link>
      <guid>http://Melodylican.github.io/2017/09/25/kafka-offset%E7%9A%84%E9%87%8D%E7%BD%AE/</guid>
      <pubDate>Sun, 24 Sep 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在spark读取kafka消息时，每次读取都会从kafka最新的offset读取。但是如果数据丢失，如果在使用Kafka来分发消息，在数据处理的过程中可能会出现处理程序出异常或者是其它的错误，会造成数据丢失或不一致。这个时候你也许会想要通过kafka把数据从新处理一遍，或者指定kafka的offset读取。kafka默认会在磁盘上保存到7天的数据，你只需要把kafka的某个topic的consumer的offset设置为某个值或者是最小值，就可以使该consumer从你设置的那个点开始消费。这就需要从zk里面修改offset的值。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在spark读取kafka消息时，每次读取都会从kafka最新的offset读取。但是如果数据丢失，如果在使用Kafka来分发消息，在数据处理的过程中可能会出现处理程序出异常或者是其它的错误，会造成数据丢失或不一致。这个时候你也许会想要通过kafka把数据从新处理一遍，或者指定kafka的offset读取。kafka默认会在磁盘上保存到7天的数据，你只需要把kafka的某个topic的consumer的offset设置为某个值或者是最小值，就可以使该consumer从你设置的那个点开始消费。这就需要从zk里面修改offset的值。<br> <a id="more"></a></p>
<h2 id="查询topic的offset的范围"><a href="#查询topic的offset的范围" class="headerlink" title="查询topic的offset的范围"></a>查询topic的offset的范围</h2><p>用下面命令可以查询到topic:DynamicRange broker:SparkMaster:9092的offset的最小值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list slave6:9092 -topic videoplay --time -2</div></pre></td></tr></table></figure></p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DynamicRange:0:1288</div></pre></td></tr></table></figure>
<h2 id="查询offset的最大值："><a href="#查询offset的最大值：" class="headerlink" title="查询offset的最大值："></a>查询offset的最大值：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list slave6:9092 -topic videoplay --time -1</div></pre></td></tr></table></figure>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DynamicRange:0:7885</div></pre></td></tr></table></figure>
<p>从上面的输出可以看出topic:DynamicRange只有一个partition:0 offset范围为:[1288,7885]</p>
<p>设置consumer group的offset<br>启动zookeeper client<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/zookeeper/bin/zkCli.sh</div></pre></td></tr></table></figure></p>
<p>通过下面命令设置consumer group:DynamicRangeGroup topic:DynamicRange partition:0的offset为1288:</p>
<p>set /consumers/DynamicRangeGroup/offsets/DynamicRange/0 1288</p>
<p>注意如果你的kafka设置了zookeeper root，比如为/kafka，那么命令应该改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set /kafka/consumers/DynamicRangeGroup/offsets/DynamicRange/0 1288</div></pre></td></tr></table></figure></p>
<h2 id="生效"><a href="#生效" class="headerlink" title="生效"></a>生效</h2><p>重启相关的应用程序，就可以从设置的offset开始读数据了。 </p>
<p>参考：<a href="https://metabroadcast.com/blog/resetting-kafka-offsets" target="_blank" rel="external">https://metabroadcast.com/blog/resetting-kafka-offsets</a></p>
]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/09/25/kafka-offset%E7%9A%84%E9%87%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spark应用案例-关于购物篮的设计</title>
      <link>http://Melodylican.github.io/2017/08/21/spark%E8%B4%AD%E7%89%A9%E7%AF%AE%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://Melodylican.github.io/2017/08/21/spark%E8%B4%AD%E7%89%A9%E7%AF%AE%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Mon, 21 Aug 2017 08:42:23 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;h3 id=&quot;购物篮的定义&quot;&gt;&lt;a href=&quot;#购物篮的定义&quot; class=&quot;headerlink&quot; title=&quot;购物篮的定义&quot;&gt;&lt;/a&gt;购物篮的定义&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="购物篮的定义"><a href="#购物篮的定义" class="headerlink" title="购物篮的定义"></a>购物篮的定义</h3><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE1.png" alt=""><br></center>

<a id="more"></a>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE2.png" alt=""><br></center><br>　<br>### 相关概念 ###<br><br><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE3.png" alt=""><br></center>　<br><br>### 步骤 ###<br><br><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE4.png" alt=""><br></center>　　<br><br>### 编程实现 ###<br><br><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE5.png" alt=""><br></center>　<br>　<br>### 步骤 ###<br><br><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE6.png" alt=""><br></center>　<br>　　<br><br>## 程序实现 ##<br><br>### 程序 ###<br><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.&#123;<span class="type">FileSystem</span>, <span class="type">Path</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</div><div class="line"></div><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * 使用SparkCore实现购物篮分析</div><div class="line">  */</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">FindAssociationRulesSparkCore</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 先从缓存中获取数据，如果不存在，直接重新获取</div><div class="line">    *</div><div class="line">    * @param items</div><div class="line">    * @param size</div><div class="line">    * @param cache</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findItemSetsByCache</span></span>(items: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)], size: <span class="type">Int</span>, cache: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]): <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = &#123;</div><div class="line">    cache.get(size).orElse &#123;</div><div class="line">      <span class="comment">// 获取值</span></div><div class="line">      <span class="keyword">val</span> result = findItemSets(items, size, cache)</div><div class="line"></div><div class="line">      <span class="comment">// 更新缓存</span></div><div class="line">      cache += size -&gt; result</div><div class="line"></div><div class="line">      <span class="comment">// 返回值</span></div><div class="line">      <span class="type">Some</span>(result)</div><div class="line">    &#125;.get</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 构建项集基于items商品列表，项集中的商品数量是size指定</div><div class="line">    *</div><div class="line">    * @param items 商品列表：eg: [A, B, C]</div><div class="line">    * @param size  最终项集包含商品的数量</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findItemSets</span></span>(items: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)], size: <span class="type">Int</span>, cache: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]): <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = &#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">// items中的每个商品都是一个项集</span></div><div class="line">      items.map(item =&gt; item :: <span class="type">Nil</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 当size不是1的时候</span></div><div class="line">      <span class="comment">// 1. 获取项集大小为size-1的项集列表</span></div><div class="line">      <span class="keyword">val</span> tmpItemSets = findItemSetsByCache(items, size - <span class="number">1</span>, cache)</div><div class="line">      <span class="comment">// 2. 给tmpItemSets中添加一个新的不重复的项 ==&gt; 数据的转换</span></div><div class="line">      <span class="keyword">val</span> itemSets = tmpItemSets.flatMap(itemSets =&gt; &#123;</div><div class="line">        <span class="comment">// 给itemSets项集添加一个新的商品ID，要求不重复</span></div><div class="line">        <span class="keyword">val</span> newItemSets = items</div><div class="line">          <span class="comment">// 将包含的商品过滤掉&amp;要求下标必须大于以及存在</span></div><div class="line">          .filter(item =&gt; !itemSets.contains(item) &amp;&amp; itemSets.forall(_._2 &lt; item._2))</div><div class="line">          <span class="comment">// 将商品添加到项集中，产生一个新的项集</span></div><div class="line">          <span class="comment">// 为了使用distinct做去重操作，进行一个排序操作</span></div><div class="line">          .map(item =&gt; (item :: itemSets))</div><div class="line"></div><div class="line">        <span class="comment">// 返回值</span></div><div class="line">        newItemSets</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 返回项集的值</span></div><div class="line">      itemSets</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="comment">// 1. 创建SparkContext</span></div><div class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</div><div class="line">      .setAppName(<span class="string">"find-association-rules"</span>)</div><div class="line">      .setMaster(<span class="string">"local[*]"</span>)</div><div class="line">    <span class="keyword">val</span> sc = <span class="type">SparkContext</span>.getOrCreate(conf)</div><div class="line"></div><div class="line">    <span class="comment">// ===========================================</span></div><div class="line">    <span class="comment">// 测试数据存储的路径</span></div><div class="line">    <span class="keyword">val</span> path = <span class="string">"data/transactions/10"</span></div><div class="line">    <span class="keyword">val</span> savePath = <span class="string">"data/transactions/result"</span></div><div class="line">    <span class="comment">// 最小支持度</span></div><div class="line">    <span class="keyword">val</span> minSupport = <span class="number">2</span></div><div class="line">    <span class="comment">// 最小置信度</span></div><div class="line">    <span class="keyword">val</span> minConfidence = <span class="number">0.4</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建rdd读取原始的交易数据，</span></div><div class="line">    <span class="comment">// 假设交易数据是按行存储的，每行是一条交易，每条交易数据包含的商品ID使用","分割</span></div><div class="line">    <span class="keyword">val</span> rdd = sc.textFile(path, <span class="number">20</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 1. 计算频繁项集</span></div><div class="line">    <span class="comment">// 1.1 获取每条交易存在的项集</span></div><div class="line">    <span class="keyword">val</span> itemSetsRDD: <span class="type">RDD</span>[<span class="type">String</span>] = rdd.flatMap(transaction =&gt; &#123;</div><div class="line">      <span class="comment">// 1) 获取当前交易所包含的商品ID</span></div><div class="line">      <span class="keyword">val</span> items = transaction</div><div class="line">        .split(<span class="string">","</span>) <span class="comment">// 分割</span></div><div class="line">        .filter(!_.isEmpty) <span class="comment">// 过滤</span></div><div class="line">        .sorted <span class="comment">//排序</span></div><div class="line">        .toList <span class="comment">// 转换为list</span></div><div class="line">        .zipWithIndex <span class="comment">// 将数据和下标合并，下标从0开始</span></div><div class="line"></div><div class="line">      <span class="comment">// 2) 构建辅助对象</span></div><div class="line">      <span class="keyword">val</span> itemSize = items.size</div><div class="line">      <span class="keyword">val</span> cache = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]()</div><div class="line"></div><div class="line">      <span class="comment">// 3) 根据获取的商品ID的信息产生项集</span></div><div class="line">      <span class="comment">// allItemSets集合中最后数据量是:2^itemSize - 1</span></div><div class="line">      <span class="keyword">val</span> allItemSets: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]] = (<span class="number">1</span> to itemSize).map(size =&gt; &#123;</div><div class="line">        <span class="comment">// 产生项集中项的数量是size的项集</span></div><div class="line">        findItemSets(items, size, cache)</div><div class="line">      &#125;).foldLeft(<span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]())((v1, v2) =&gt; &#123;</div><div class="line">        v2.map(_.map(_._1)) ::: v1</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 4) 返回结果</span></div><div class="line">      allItemSets.map(_.mkString(<span class="string">","</span>))</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 1.2 获取频繁项集</span></div><div class="line">    <span class="keyword">val</span> supportedItemSetsRDD = itemSetsRDD</div><div class="line">      <span class="comment">// 数据转换</span></div><div class="line">      .map(items =&gt; (items, <span class="number">1</span>))</div><div class="line">      <span class="comment">// 聚合求支持度</span></div><div class="line">      .reduceByKey(_ + _)</div><div class="line">      <span class="comment">// 过滤产生频繁项集</span></div><div class="line">      .filter(_._2 &gt;= minSupport)</div><div class="line"></div><div class="line">    <span class="comment">// 2. 计算关联规则</span></div><div class="line">    <span class="comment">// 2.1 对每个频繁项集获取子项集</span></div><div class="line">    <span class="keyword">val</span> subSupportedItemSetsRDD = supportedItemSetsRDD.flatMap(tuple =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> itemSets = tuple._1.split(<span class="string">","</span>).toList.zipWithIndex <span class="comment">// 频繁项集</span></div><div class="line">      <span class="keyword">val</span> frequency = tuple._2 <span class="comment">// 该频繁项集的支持度</span></div><div class="line"></div><div class="line">      <span class="comment">// 2) 构建辅助对象</span></div><div class="line">      <span class="keyword">val</span> itemSize = itemSets.size</div><div class="line">      <span class="keyword">val</span> cache = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]()</div><div class="line"></div><div class="line">      <span class="comment">// 3) 获取子项集</span></div><div class="line">      <span class="keyword">val</span> allSubItemSets: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]] = (<span class="number">1</span> to itemSize).map(size =&gt; &#123;</div><div class="line">        <span class="comment">// 产生项集中项的数量是size的项集</span></div><div class="line">        findItemSets(itemSets, size, cache)</div><div class="line">      &#125;).foldLeft(<span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]())((v1, v2) =&gt; &#123;</div><div class="line">        v2.map(_.map(_._1)) ::: v1</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 4) 转换数据并输出</span></div><div class="line">      <span class="keyword">val</span> items = itemSets.map(_._1)</div><div class="line">      allSubItemSets.map(subItemSets =&gt; &#123;</div><div class="line">        <span class="comment">// (A,B,frequency) ==&gt; 表示A出现的时候B也出现的次数是frequency次</span></div><div class="line">        <span class="comment">// 当subItemSets就是itemSets的时候，返回的二元组的第二个元素的(元组)第一个元素是空的列表</span></div><div class="line">        (subItemSets.mkString(<span class="string">","</span>), ((items.toBuffer -- subItemSets).toList.mkString(<span class="string">","</span>), frequency))</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 计算置信度</span></div><div class="line">    <span class="keyword">val</span> assocRulesRDD = subSupportedItemSetsRDD</div><div class="line">      .groupByKey() <span class="comment">// 数据聚合</span></div><div class="line">      .flatMap(tuple =&gt; &#123;</div><div class="line">      <span class="comment">// 计算执行度: (A, B, k) =&gt; A存在的时候B也存储的几率是k</span></div><div class="line">      <span class="comment">// A就是tuple的第一个元素</span></div><div class="line">      <span class="comment">// 获取左件</span></div><div class="line">      <span class="keyword">val</span> lhs = tuple._1.split(<span class="string">","</span>).mkString(<span class="string">"&lt;"</span>, <span class="string">","</span>, <span class="string">"&gt;"</span>)</div><div class="line"></div><div class="line">      <span class="comment">// 获取左件在所有的交易中出现的总的次数 tuple._2中第一个元素为空的数据就是总的次数</span></div><div class="line">      <span class="keyword">val</span> frequency = tuple._2</div><div class="line">        <span class="comment">// 只要第一个元素为空的值，表示from本身</span></div><div class="line">        .filter(_._1.isEmpty)</div><div class="line">        <span class="comment">// 需要的是第二个元素</span></div><div class="line">        .map(_._2).toList <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> head :: <span class="type">Nil</span> =&gt; head</div><div class="line">        <span class="keyword">case</span> _ =&gt; &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"异常"</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 计算右件出现次数占左件次数的百分比, 并返回最终结果</span></div><div class="line">      tuple._2</div><div class="line">        <span class="comment">// 要求第一个数据非空</span></div><div class="line">        .filter(!_._1.isEmpty)</div><div class="line">        <span class="comment">// 数据转换，获取置信度</span></div><div class="line">        .map &#123;</div><div class="line">        <span class="keyword">case</span> (rhs, support) =&gt; &#123;</div><div class="line">          <span class="comment">// 计算置信度</span></div><div class="line">          (lhs, rhs.split(<span class="string">","</span>).mkString(<span class="string">"&lt;"</span>, <span class="string">","</span>, <span class="string">"&gt;"</span>), <span class="number">1.0</span> * support / frequency)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 过滤置信度太低的数据</span></div><div class="line">    <span class="keyword">val</span> resultRDD = assocRulesRDD.filter(_._3 &gt;= minConfidence)</div><div class="line"></div><div class="line">    <span class="comment">// 3. RDD数据保存</span></div><div class="line">    <span class="comment">//resultRDD.collect()</span></div><div class="line">    <span class="type">FileSystem</span>.get(sc.hadoopConfiguration).delete(<span class="keyword">new</span> <span class="type">Path</span>(savePath), <span class="literal">true</span>)</div><div class="line">    <span class="comment">//resultRDD.repartition(1).saveAsTextFile(savePath)</span></div><div class="line"></div><div class="line">    <span class="comment">// ===========================================</span></div><div class="line">    sc.stop()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>### 注意点（本地的完全运行） ###<br><br>　　不需要开启服务，也不需要上传文件，讲文件保存在本地的方式<br><center><br><img src="http://ojwkevhas.bkt.clouddn.com/spark%E8%B4%AD%E7%89%A9%E7%AF%AE7.png" alt=""><br></center>

<h2 id="优化程序"><a href="#优化程序" class="headerlink" title="优化程序"></a>优化程序</h2><p>　　1.优化的是相集的个数</p>
<p>　　2.使用广播变量</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.&#123;<span class="type">FileSystem</span>, <span class="type">Path</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.broadcast.<span class="type">Broadcast</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</div><div class="line"></div><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * 使用SparkCore实现购物篮分析</div><div class="line">  */</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">FindAssociationRulesSparkCore</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 先从缓存中获取数据，如果不存在，直接重新获取</div><div class="line">    *</div><div class="line">    * @param items</div><div class="line">    * @param size</div><div class="line">    * @param cache</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findItemSetsByCache</span></span>(items: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)], size: <span class="type">Int</span>, cache: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]): <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = &#123;</div><div class="line">    cache.get(size).orElse &#123;</div><div class="line">      <span class="comment">// 获取值</span></div><div class="line">      <span class="keyword">val</span> result = findItemSets(items, size, cache)</div><div class="line"></div><div class="line">      <span class="comment">// 更新缓存</span></div><div class="line">      cache += size -&gt; result</div><div class="line"></div><div class="line">      <span class="comment">// 返回值</span></div><div class="line">      <span class="type">Some</span>(result)</div><div class="line">    &#125;.get</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">    * 构建项集基于items商品列表，项集中的商品数量是size指定</div><div class="line">    *</div><div class="line">    * @param items 商品列表：eg: [A, B, C]</div><div class="line">    * @param size  最终项集包含商品的数量</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findItemSets</span></span>(items: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)], size: <span class="type">Int</span>, cache: mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]): <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = &#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">// items中的每个商品都是一个项集</span></div><div class="line">      items.map(item =&gt; item :: <span class="type">Nil</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 当size不是1的时候</span></div><div class="line">      <span class="comment">// 1. 获取项集大小为size-1的项集列表</span></div><div class="line">      <span class="keyword">val</span> tmpItemSets = findItemSetsByCache(items, size - <span class="number">1</span>, cache)</div><div class="line">      <span class="comment">// 2. 给tmpItemSets中添加一个新的不重复的项 ==&gt; 数据的转换</span></div><div class="line">      <span class="keyword">val</span> itemSets = tmpItemSets.flatMap(itemSets =&gt; &#123;</div><div class="line">        <span class="comment">// 给itemSets项集添加一个新的商品ID，要求不重复</span></div><div class="line">        <span class="keyword">val</span> newItemSets = items</div><div class="line">          <span class="comment">// 将包含的商品过滤掉&amp;要求下标必须大于以及存在</span></div><div class="line">          .filter(item =&gt; !itemSets.contains(item) &amp;&amp; itemSets.forall(_._2 &lt; item._2))</div><div class="line">          <span class="comment">// 将商品添加到项集中，产生一个新的项集</span></div><div class="line">          <span class="comment">// 为了使用distinct做去重操作，进行一个排序操作</span></div><div class="line">          .map(item =&gt; (item :: itemSets))</div><div class="line"></div><div class="line">        <span class="comment">// 返回值</span></div><div class="line">        newItemSets</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 返回项集的值</span></div><div class="line">      itemSets</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> n = <span class="number">10000</span></div><div class="line">    <span class="comment">// 1. 创建SparkContext</span></div><div class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</div><div class="line">      .setAppName(<span class="string">s"find-association-rules-<span class="subst">$&#123;n&#125;</span>"</span>)</div><div class="line">      .setMaster(<span class="string">"local[*]"</span>)</div><div class="line">    <span class="comment">//      .set("spark.eventLog.enabled", "true")</span></div><div class="line">    <span class="comment">//      .set("spark.eventLog.dir","hdfs://hadoop-senior01:8020/spark-history")</span></div><div class="line">    <span class="comment">//      .set("spark.executor.memory","3g")</span></div><div class="line">    <span class="keyword">val</span> sc = <span class="type">SparkContext</span>.getOrCreate(conf)</div><div class="line"></div><div class="line">    <span class="comment">// ===========================================</span></div><div class="line">    <span class="comment">// 测试数据存储的路径</span></div><div class="line">    <span class="keyword">val</span> path = <span class="string">s"data/transactions/<span class="subst">$&#123;n&#125;</span>"</span></div><div class="line">    <span class="keyword">val</span> savePath = <span class="string">s"result2/<span class="subst">$&#123;n&#125;</span>"</span></div><div class="line">    <span class="comment">// 最小支持度</span></div><div class="line">    <span class="keyword">val</span> minSupport = <span class="number">2</span></div><div class="line">    <span class="comment">// 最小置信度</span></div><div class="line">    <span class="keyword">val</span> minConfidence = <span class="number">0.1</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建rdd读取原始的交易数据，</span></div><div class="line">    <span class="comment">// 假设交易数据是按行存储的，每行是一条交易，每条交易数据包含的商品ID使用","分割</span></div><div class="line">    <span class="keyword">val</span> rdd = sc.textFile(path, <span class="number">20</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 过滤无效数据：对于在整个交易集合中出现比较少的商品过滤掉，先进行需要过滤的商品的RDD数据</span></div><div class="line">    <span class="keyword">val</span> minGoodCount = <span class="number">3</span> <span class="comment">// 要求商品在整个交易集中至少出现3次</span></div><div class="line">    <span class="keyword">val</span> needFilterGoodsRDD = rdd</div><div class="line">      .flatMap(transaction =&gt; transaction</div><div class="line">        .split(<span class="string">","</span>)</div><div class="line">        .filter(!_.isEmpty)</div><div class="line">        .map(good =&gt; (good, <span class="number">1</span>))</div><div class="line">      )</div><div class="line">      .reduceByKey(_ + _)</div><div class="line">      .filter(_._2 &lt; minGoodCount)</div><div class="line">      .map(_._1)</div><div class="line">    <span class="comment">// 使用广播变量将数据广播输出</span></div><div class="line">    <span class="keyword">val</span> needFilterGoods: <span class="type">Broadcast</span>[<span class="type">List</span>[<span class="type">String</span>]] = sc.broadcast(needFilterGoodsRDD.collect().toList)</div><div class="line"></div><div class="line">    <span class="comment">// 1. 计算频繁项集</span></div><div class="line">    <span class="comment">// 1.1 获取每条交易存在的项集</span></div><div class="line">    <span class="keyword">val</span> itemSetsRDD: <span class="type">RDD</span>[<span class="type">String</span>] = rdd.flatMap(transaction =&gt; &#123;</div><div class="line">      <span class="comment">// 1) 获取当前交易所包含的商品ID</span></div><div class="line">      <span class="keyword">val</span> goods: <span class="type">Array</span>[<span class="type">String</span>] = transaction</div><div class="line">        .split(<span class="string">","</span>) <span class="comment">// 分割</span></div><div class="line">        .filter(!_.isEmpty) <span class="comment">// 过滤</span></div><div class="line"></div><div class="line"></div><div class="line">      <span class="comment">// 将需要过滤的数据过滤掉</span></div><div class="line">      <span class="keyword">val</span> items = (goods.toBuffer -- needFilterGoods.value)</div><div class="line">        .sorted <span class="comment">//排序</span></div><div class="line">        .toList <span class="comment">// 转换为list</span></div><div class="line">        .zipWithIndex <span class="comment">// 将数据和下标合并，下标从0开始</span></div><div class="line"></div><div class="line">      <span class="comment">// 2) 构建辅助对象</span></div><div class="line">      <span class="comment">// 最大的项集只允许存在5个项的，5怎么来？根据业务规则&amp;根据运行之后的情况</span></div><div class="line">      <span class="keyword">val</span> itemSize = <span class="type">Math</span>.min(items.size, <span class="number">5</span>)</div><div class="line">      <span class="keyword">val</span> cache = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]()</div><div class="line"></div><div class="line">      <span class="comment">// 3) 根据获取的商品ID的信息产生项集</span></div><div class="line">      <span class="comment">// allItemSets集合中最后数据量是:2^itemSize - 1</span></div><div class="line">      <span class="keyword">val</span> allItemSets: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]] = (<span class="number">1</span> to itemSize).map(size =&gt; &#123;</div><div class="line">        <span class="comment">// 产生项集中项的数量是size的项集</span></div><div class="line">        findItemSets(items, size, cache)</div><div class="line">      &#125;).foldLeft(<span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]())((v1, v2) =&gt; &#123;</div><div class="line">        v2.map(_.map(_._1)) ::: v1</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 4) 返回结果</span></div><div class="line">      allItemSets.map(_.mkString(<span class="string">","</span>))</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 1.2 获取频繁项集</span></div><div class="line">    <span class="keyword">val</span> supportedItemSetsRDD = itemSetsRDD</div><div class="line">      <span class="comment">// 数据转换</span></div><div class="line">      .map(items =&gt; (items, <span class="number">1</span>))</div><div class="line">      <span class="comment">// 聚合求支持度</span></div><div class="line">      .reduceByKey(_ + _)</div><div class="line">      <span class="comment">// 过滤产生频繁项集</span></div><div class="line">      .filter(_._2 &gt;= minSupport)</div><div class="line"></div><div class="line">    <span class="comment">// 2. 计算关联规则</span></div><div class="line">    <span class="comment">// 2.1 对每个频繁项集获取子项集</span></div><div class="line">    <span class="keyword">val</span> subSupportedItemSetsRDD = supportedItemSetsRDD.flatMap(tuple =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> itemSets = tuple._1.split(<span class="string">","</span>).toList.zipWithIndex <span class="comment">// 频繁项集</span></div><div class="line">      <span class="keyword">val</span> frequency = tuple._2 <span class="comment">// 该频繁项集的支持度</span></div><div class="line"></div><div class="line">      <span class="comment">// 2) 构建辅助对象</span></div><div class="line">      <span class="keyword">val</span> itemSize = itemSets.size</div><div class="line">      <span class="keyword">val</span> cache = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]]]()</div><div class="line"></div><div class="line">      <span class="comment">// 3) 获取子项集</span></div><div class="line">      <span class="keyword">val</span> allSubItemSets: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]] = (<span class="number">1</span> to itemSize).map(size =&gt; &#123;</div><div class="line">        <span class="comment">// 产生项集中项的数量是size的项集</span></div><div class="line">        findItemSets(itemSets, size, cache)</div><div class="line">      &#125;).foldLeft(<span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]())((v1, v2) =&gt; &#123;</div><div class="line">        v2.map(_.map(_._1)) ::: v1</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="comment">// 4) 转换数据并输出</span></div><div class="line">      <span class="keyword">val</span> items = itemSets.map(_._1)</div><div class="line">      allSubItemSets.map(subItemSets =&gt; &#123;</div><div class="line">        <span class="comment">// (A,B,frequency) ==&gt; 表示A出现的时候B也出现的次数是frequency次</span></div><div class="line">        <span class="comment">// 当subItemSets就是itemSets的时候，返回的二元组的第二个元素的(元组)第一个元素是空的列表</span></div><div class="line">        (subItemSets.mkString(<span class="string">","</span>), ((items.toBuffer -- subItemSets).toList.mkString(<span class="string">","</span>), frequency))</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 计算置信度</span></div><div class="line">    <span class="keyword">val</span> assocRulesRDD = subSupportedItemSetsRDD</div><div class="line">      .groupByKey() <span class="comment">// 数据聚合</span></div><div class="line">      .flatMap(tuple =&gt; &#123;</div><div class="line">      <span class="comment">// 计算执行度: (A, B, k) =&gt; A存在的时候B也存储的几率是k</span></div><div class="line">      <span class="comment">// A就是tuple的第一个元素</span></div><div class="line">      <span class="comment">// 获取左件</span></div><div class="line">      <span class="keyword">val</span> lhs = tuple._1.split(<span class="string">","</span>).mkString(<span class="string">"&lt;"</span>, <span class="string">","</span>, <span class="string">"&gt;"</span>)</div><div class="line"></div><div class="line">      <span class="comment">// 获取左件在所有的交易中出现的总的次数 tuple._2中第一个元素为空的数据就是总的次数</span></div><div class="line">      <span class="keyword">val</span> frequency = tuple._2</div><div class="line">        <span class="comment">// 只要第一个元素为空的值，表示from本身</span></div><div class="line">        .filter(_._1.isEmpty)</div><div class="line">        <span class="comment">// 需要的是第二个元素</span></div><div class="line">        .map(_._2).toList <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> head :: <span class="type">Nil</span> =&gt; head</div><div class="line">        <span class="keyword">case</span> _ =&gt; &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"异常"</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 计算右件出现次数占左件次数的百分比, 并返回最终结果</span></div><div class="line">      tuple._2</div><div class="line">        <span class="comment">// 要求第一个数据非空</span></div><div class="line">        .filter(!_._1.isEmpty)</div><div class="line">        <span class="comment">// 数据转换，获取置信度</span></div><div class="line">        .map &#123;</div><div class="line">        <span class="keyword">case</span> (rhs, support) =&gt; &#123;</div><div class="line">          <span class="comment">// 计算置信度</span></div><div class="line">          (lhs, rhs.split(<span class="string">","</span>).mkString(<span class="string">"&lt;"</span>, <span class="string">","</span>, <span class="string">"&gt;"</span>), <span class="number">1.0</span> * support / frequency)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 过滤置信度太低的数据</span></div><div class="line">    <span class="keyword">val</span> resultRDD = assocRulesRDD.filter(_._3 &gt;= minConfidence)</div><div class="line"></div><div class="line">    <span class="comment">// 3. RDD数据保存</span></div><div class="line">    <span class="type">FileSystem</span>.get(sc.hadoopConfiguration).delete(<span class="keyword">new</span> <span class="type">Path</span>(savePath), <span class="literal">true</span>)</div><div class="line">    resultRDD.repartition(<span class="number">1</span>).saveAsTextFile(savePath)</div><div class="line"></div><div class="line">    <span class="comment">// ===========================================</span></div><div class="line">    sc.stop()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="grey" size="1">注：此博客仅供博主自身复习用</font>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/21/spark%E8%B4%AD%E7%89%A9%E7%AF%AE%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spark应用案例-Spark完成PV和UV的计算</title>
      <link>http://Melodylican.github.io/2017/08/20/spark%E5%AE%8C%E6%88%90PV%E5%92%8CUV%E7%9A%84%E8%AE%A1%E7%AE%97/</link>
      <guid>http://Melodylican.github.io/2017/08/20/spark%E5%AE%8C%E6%88%90PV%E5%92%8CUV%E7%9A%84%E8%AE%A1%E7%AE%97/</guid>
      <pubDate>Sun, 20 Aug 2017 08:42:23 GMT</pubDate>
      <description>
      
        &lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
      
      </description>
      
      <content:encoded><![CDATA[<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">LogPVAndUV</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span>=&#123;</div><div class="line">        <span class="keyword">val</span> conf=<span class="keyword">new</span> <span class="type">SparkConf</span>()</div><div class="line">            .setMaster(<span class="string">"local[*]"</span>)</div><div class="line">            .setAppName(<span class="string">"PVAndUV"</span>)</div><div class="line">        <span class="keyword">val</span> sc=<span class="type">SparkContext</span>.getOrCreate(conf)</div><div class="line">        <span class="keyword">val</span> logPath=<span class="string">"/user/***/spark/logs/page_views.data"</span></div><div class="line">        <span class="keyword">val</span> logRDD=sc.textFile(logPath)</div><div class="line">        <span class="keyword">val</span> filterRDD=logRDD.filter(_.length&gt;<span class="number">0</span>)</div><div class="line">        <span class="comment">//转换</span></div><div class="line">        <span class="keyword">val</span> mapRDD=filterRDD.map(line=&gt;&#123;</div><div class="line">            <span class="keyword">val</span> arr=line.split(<span class="string">"\t"</span>)</div><div class="line">            <span class="keyword">if</span>(arr.length==<span class="number">7</span>)&#123;</div><div class="line">                <span class="keyword">val</span> date=arr(<span class="number">0</span>).trim</div><div class="line">                <span class="keyword">val</span> url=arr(<span class="number">1</span>)</div><div class="line">                <span class="keyword">val</span> uuid=arr(<span class="number">2</span>)</div><div class="line">                (date.subString(<span class="number">0</span>,<span class="type">Math</span>.min(<span class="number">10.</span>date.length)).trim,url,uuid)</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                (<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;).filter(tuple=&gt;tuple._1!=<span class="literal">null</span>&amp;&amp;tuple._1.length&gt;<span class="number">0</span>)</div><div class="line">        <span class="comment">//PV计算</span></div><div class="line">        <span class="keyword">val</span> pvRDD=mapRDD</div><div class="line">            .filter(tuple=&gt;tuple._2.length&gt;<span class="number">0</span>)</div><div class="line">            .map(tuple=&gt;(tuple._1,<span class="number">1</span>))</div><div class="line">            .reduceByKey(_+_)</div><div class="line">        <span class="comment">//UV计算</span></div><div class="line">        <span class="keyword">val</span> uvRDD=mapRDD</div><div class="line">            .filter(tuple=&gt;tuple._3.length&gt;<span class="number">0</span>)</div><div class="line">            .map(tuple=&gt;(tuple._1,tuple._3))</div><div class="line">            .distinct</div><div class="line">            .reduceByKey(_+_)</div><div class="line">        <span class="comment">//合并</span></div><div class="line">        <span class="keyword">val</span> pvAndUv=pvRDD.join(uvRDD).map&#123;</div><div class="line">            <span class="keyword">case</span> (date,(pv,uv))=&gt;&#123;</div><div class="line">                (date,pv,uv)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//输出</span></div><div class="line">        pvAndUv.saveAsTextFile(<span class="string">"/user/***/spark/output/"</span>+<span class="type">System</span>.currentTimeMillis())</div><div class="line">        sc.stop()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="grey" size="1">注：此博客仅供博主自身复习用</font>]]></content:encoded>
      
      <comments>http://Melodylican.github.io/2017/08/20/spark%E5%AE%8C%E6%88%90PV%E5%92%8CUV%E7%9A%84%E8%AE%A1%E7%AE%97/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
